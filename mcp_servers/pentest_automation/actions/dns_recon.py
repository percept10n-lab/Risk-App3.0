"""DNS Reconnaissance action.

Inspired by NeuroSploit's recon_integration — performs DNS-based
reconnaissance including reverse DNS, PTR lookups, and common
subdomain/hostname resolution for the target network.
"""

import asyncio
import ipaddress
import socket
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

# Common hostnames to check in local networks
LOCAL_HOSTNAMES = [
    "router", "gateway", "firewall", "switch",
    "nas", "server", "backup", "printer",
    "ap", "wifi", "wlan", "proxy",
    "pfsense", "opnsense", "pihole", "adguard",
    "homeassistant", "hass", "unifi", "ubnt",
    "synology", "qnap", "truenas", "freenas",
    "proxmox", "esxi", "vcenter",
    "gitlab", "jenkins", "grafana", "portainer",
    "nextcloud", "plex", "jellyfin",
]

# Common mDNS / local domain suffixes
LOCAL_DOMAINS = [
    ".local",
    ".lan",
    ".home",
    ".internal",
    ".localdomain",
]


def _is_in_scope(target: str) -> bool:
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class DNSReconAction:
    """DNS reconnaissance for local network targets.

    Performs reverse DNS lookups, PTR record resolution, and probes
    for common local hostnames that may resolve to the target.
    Based on NeuroSploit's recon_integration module.
    """

    action_id = "dns_recon"
    name = "DNS Reconnaissance"
    description = "Reverse DNS, PTR lookups, and local hostname discovery for network reconnaissance."
    risk_level = "low"
    category = "neurosploit"

    async def execute(self, target: str) -> list[dict]:
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs are permitted.",
            }]

        logger.info("Starting DNS reconnaissance", target=target)
        findings = []
        loop = asyncio.get_event_loop()

        # Phase 1: Reverse DNS lookup
        reverse_names = await self._reverse_dns(target, loop)
        if reverse_names:
            findings.append({
                "title": f"Reverse DNS records found for {target}",
                "severity": "info",
                "category": "info",
                "description": f"Reverse DNS (PTR) records resolve {target} to hostnames.",
                "evidence": f"IP: {target}\nReverse DNS:\n" + "\n".join(f"  - {name}" for name in reverse_names),
                "remediation": "Review DNS records to ensure no sensitive information is leaked.",
            })

        # Phase 2: Check local hostnames resolving to target
        hostname_matches = await self._check_local_hostnames(target, loop)
        if hostname_matches:
            findings.append({
                "title": f"Local hostnames resolving to {target}",
                "severity": "low",
                "category": "info",
                "description": "Known local service hostnames resolve to this target, indicating the device's role.",
                "evidence": (
                    f"Hostnames resolving to {target}:\n"
                    + "\n".join(f"  - {name} -> {ip}" for name, ip in hostname_matches)
                ),
                "remediation": "Ensure device naming doesn't expose sensitive infrastructure details.",
            })

            # Check for security-sensitive services
            sensitive = [n for n, _ in hostname_matches if any(
                s in n.lower() for s in ["nas", "backup", "server", "gitlab", "jenkins", "proxmox", "esxi"]
            )]
            if sensitive:
                findings.append({
                    "title": f"Infrastructure service identified: {', '.join(sensitive)}",
                    "severity": "medium",
                    "category": "exposure",
                    "description": "The target hosts infrastructure services that should be carefully secured.",
                    "evidence": f"Identified services: {', '.join(sensitive)}",
                    "remediation": "Ensure these services are properly firewalled, use strong authentication, and are kept updated.",
                })

        # Phase 3: Scan neighboring IPs for reverse DNS (±5 from target)
        neighbor_info = await self._scan_neighbors(target, loop)
        if neighbor_info:
            findings.append({
                "title": f"Neighboring hosts discovered around {target}",
                "severity": "info",
                "category": "info",
                "description": "Other hosts found in the same subnet via reverse DNS.",
                "evidence": (
                    f"Network neighborhood of {target}:\n"
                    + "\n".join(f"  - {ip} -> {name}" for ip, name in neighbor_info)
                ),
                "remediation": "Review network segmentation to ensure proper isolation.",
            })

        if not findings:
            findings.append({
                "title": f"No DNS information found for {target}",
                "severity": "info",
                "category": "info",
                "description": "No reverse DNS records or local hostname matches found.",
                "evidence": f"Target: {target}\nReverse DNS: None\nHostname matches: None",
                "remediation": "No action required.",
            })

        logger.info("DNS reconnaissance complete", target=target, finding_count=len(findings))
        return findings

    async def _reverse_dns(self, target: str, loop) -> list[str]:
        """Perform reverse DNS lookup."""
        try:
            result = await asyncio.wait_for(
                loop.run_in_executor(None, socket.gethostbyaddr, target),
                timeout=5,
            )
            names = [result[0]] + list(result[1]) if result[1] else [result[0]]
            return [n for n in names if n]
        except (socket.herror, socket.gaierror, asyncio.TimeoutError, OSError):
            return []

    async def _check_local_hostnames(self, target: str, loop) -> list[tuple[str, str]]:
        """Check if common local hostnames resolve to the target."""
        matches = []
        semaphore = asyncio.Semaphore(20)

        async def check_hostname(hostname: str):
            async with semaphore:
                for domain in LOCAL_DOMAINS:
                    fqdn = hostname + domain
                    try:
                        result = await asyncio.wait_for(
                            loop.run_in_executor(None, socket.gethostbyname, fqdn),
                            timeout=2,
                        )
                        if result == target:
                            matches.append((fqdn, result))
                    except (socket.gaierror, asyncio.TimeoutError, OSError):
                        continue

                # Also try bare hostname
                try:
                    result = await asyncio.wait_for(
                        loop.run_in_executor(None, socket.gethostbyname, hostname),
                        timeout=2,
                    )
                    if result == target:
                        matches.append((hostname, result))
                except (socket.gaierror, asyncio.TimeoutError, OSError):
                    pass

        tasks = [check_hostname(h) for h in LOCAL_HOSTNAMES]
        await asyncio.gather(*tasks, return_exceptions=True)
        return matches

    async def _scan_neighbors(self, target: str, loop) -> list[tuple[str, str]]:
        """Scan neighboring IPs (±5) for reverse DNS entries."""
        neighbors = []
        try:
            addr = ipaddress.ip_address(target)
        except ValueError:
            return []

        semaphore = asyncio.Semaphore(10)

        async def check_neighbor(ip_str: str):
            async with semaphore:
                try:
                    result = await asyncio.wait_for(
                        loop.run_in_executor(None, socket.gethostbyaddr, ip_str),
                        timeout=2,
                    )
                    if result[0]:
                        neighbors.append((ip_str, result[0]))
                except (socket.herror, socket.gaierror, asyncio.TimeoutError, OSError):
                    pass

        tasks = []
        for offset in range(-5, 6):
            if offset == 0:
                continue
            neighbor_ip = addr + offset
            if _is_in_scope(str(neighbor_ip)):
                tasks.append(check_neighbor(str(neighbor_ip)))

        await asyncio.gather(*tasks, return_exceptions=True)
        return neighbors

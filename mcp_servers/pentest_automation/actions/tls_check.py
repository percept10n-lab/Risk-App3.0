import asyncio
import ipaddress
import ssl
from datetime import datetime
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

WEAK_CIPHERS = {"RC4", "DES", "3DES", "NULL", "EXPORT", "anon", "MD5"}
WEAK_PROTOCOLS = {"SSLv2", "SSLv3", "TLSv1", "TLSv1.0", "TLSv1.1"}


def _is_in_scope(target: str) -> bool:
    """Validate that target IP is within RFC 1918 private ranges."""
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class TLSCheckAction:
    """Check TLS version, cipher suite, and certificate validity.

    Connects to a TLS-enabled service and inspects the negotiated protocol
    version, cipher suite strength, and certificate properties.
    """

    action_id = "tls_check"
    name = "TLS Configuration Check"
    description = "Analyze TLS version, cipher suites, and certificate validity for weak configurations."
    risk_level = "low"

    async def execute(self, target: str, port: int = 443) -> list[dict]:
        """Execute TLS configuration check.

        Args:
            target: IP address to check (must be RFC 1918).
            port: TLS port number.

        Returns:
            List of finding dicts for weak TLS configurations.
        """
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges. Action aborted.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8) are permitted.",
            }]

        logger.info("Starting TLS check", target=target, port=port)
        findings = []

        try:
            cert_info, protocol, cipher = await self._get_tls_info(target, port)
        except Exception as e:
            logger.warning("TLS check failed", target=target, port=port, error=str(e))
            return [{
                "title": f"TLS connection failed on port {port}",
                "severity": "high",
                "category": "vuln",
                "description": f"Could not establish TLS connection to {target}:{port}: {str(e)}",
                "evidence": str(e),
                "remediation": "Verify TLS is properly configured and the service is running.",
            }]

        # Check protocol version
        if protocol and protocol in WEAK_PROTOCOLS:
            findings.append({
                "title": f"Weak TLS protocol version: {protocol}",
                "severity": "high",
                "category": "vuln",
                "description": f"Server negotiated {protocol} which has known vulnerabilities. TLS 1.2 or 1.3 should be required.",
                "evidence": f"Negotiated protocol: {protocol}",
                "remediation": "Disable TLS 1.0 and 1.1. Configure minimum TLS 1.2.",
            })
        elif protocol:
            findings.append({
                "title": f"TLS protocol version: {protocol}",
                "severity": "info",
                "category": "info",
                "description": f"Server uses {protocol}.",
                "evidence": f"Negotiated protocol: {protocol}",
                "remediation": None,
            })

        # Check cipher strength
        if cipher:
            cipher_name = cipher[0] if isinstance(cipher, tuple) else str(cipher)
            is_weak = any(weak in cipher_name.upper() for weak in WEAK_CIPHERS)
            if is_weak:
                findings.append({
                    "title": f"Weak cipher suite: {cipher_name}",
                    "severity": "high",
                    "category": "vuln",
                    "description": "Server negotiated a cipher suite with known weaknesses.",
                    "evidence": f"Negotiated cipher: {cipher_name}",
                    "remediation": "Configure server to use strong cipher suites only (AES-GCM, ChaCha20-Poly1305).",
                })
            else:
                findings.append({
                    "title": f"Cipher suite: {cipher_name}",
                    "severity": "info",
                    "category": "info",
                    "description": f"Server negotiated cipher suite: {cipher_name}.",
                    "evidence": f"Negotiated cipher: {cipher_name}",
                    "remediation": None,
                })

        # Check certificate properties
        if cert_info:
            cert_findings = self._analyze_certificate(cert_info, target, port)
            findings.extend(cert_findings)

        logger.info("TLS check complete", target=target, finding_count=len(findings))
        return findings

    def _analyze_certificate(self, cert_info: dict, target: str, port: int) -> list[dict]:
        """Analyze TLS certificate for issues."""
        findings = []

        # Expiry check
        not_after = cert_info.get("notAfter")
        if not_after:
            try:
                expiry = datetime.strptime(not_after, "%b %d %H:%M:%S %Y %Z")
                days_until = (expiry - datetime.utcnow()).days
                if days_until < 0:
                    findings.append({
                        "title": "TLS certificate has expired",
                        "severity": "critical",
                        "category": "vuln",
                        "description": f"Certificate expired {abs(days_until)} days ago on {not_after}.",
                        "evidence": f"Certificate notAfter: {not_after}",
                        "remediation": "Renew the TLS certificate immediately.",
                    })
                elif days_until < 30:
                    findings.append({
                        "title": f"TLS certificate expires in {days_until} days",
                        "severity": "medium",
                        "category": "misconfig",
                        "description": f"Certificate expires on {not_after}. Renew soon to avoid service disruption.",
                        "evidence": f"Certificate notAfter: {not_after}, days remaining: {days_until}",
                        "remediation": "Renew the TLS certificate before expiration.",
                    })
            except (ValueError, TypeError):
                pass

        # Self-signed check
        issuer = cert_info.get("issuer", ())
        subject = cert_info.get("subject", ())
        if issuer and subject and issuer == subject:
            findings.append({
                "title": "Self-signed TLS certificate",
                "severity": "low",
                "category": "misconfig",
                "description": "Certificate is self-signed. This prevents proper certificate validation by clients.",
                "evidence": f"Issuer matches Subject: {issuer}",
                "remediation": "For internal services, consider using a local CA. For external, use Let's Encrypt or a trusted CA.",
            })

        # Extract and report subject CN
        subject_cn = ""
        for rdn in subject:
            for attr in rdn:
                if attr[0] == "commonName":
                    subject_cn = attr[1]
        if subject_cn:
            findings.append({
                "title": f"TLS certificate subject: {subject_cn}",
                "severity": "info",
                "category": "info",
                "description": f"Certificate issued for: {subject_cn}",
                "evidence": f"Subject CN: {subject_cn}",
                "remediation": None,
            })

        return findings

    async def _get_tls_info(self, target: str, port: int) -> tuple[dict, str, tuple]:
        """Connect to TLS service and extract certificate and protocol info."""
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE

        reader, writer = await asyncio.wait_for(
            asyncio.open_connection(target, port, ssl=ctx), timeout=10
        )

        ssl_obj = writer.get_extra_info("ssl_object")
        cert = ssl_obj.getpeercert(binary_form=False) if ssl_obj else {}
        protocol = ssl_obj.version() if ssl_obj else ""
        cipher = ssl_obj.cipher() if ssl_obj else ()

        writer.close()
        await writer.wait_closed()

        return cert or {}, protocol or "", cipher or ()

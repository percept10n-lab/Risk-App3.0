import asyncio
import ipaddress
import re
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

WEAK_KEY_EXCHANGE = {
    "diffie-hellman-group1-sha1",
    "diffie-hellman-group14-sha1",
    "diffie-hellman-group-exchange-sha1",
}
WEAK_CIPHERS = {
    "arcfour", "arcfour128", "arcfour256",
    "3des-cbc", "blowfish-cbc", "cast128-cbc", "des-cbc",
}
WEAK_MACS = {
    "hmac-md5", "hmac-md5-96", "hmac-sha1-96",
    "umac-64@openssh.com",
}
WEAK_HOST_KEYS = {"ssh-dss"}


def _is_in_scope(target: str) -> bool:
    """Validate that target IP is within RFC 1918 private ranges."""
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class SSHHardeningAction:
    """Check SSH server configuration for hardening issues.

    Analyzes SSH banner, key exchange algorithms, authentication methods,
    and checks for root login capability.
    """

    action_id = "ssh_hardening"
    name = "SSH Hardening Check"
    description = "Analyze SSH banner, key exchange algorithms, auth methods, and root login configuration."
    risk_level = "low"

    async def execute(self, target: str, port: int = 22, on_progress=None) -> list[dict]:
        """Execute SSH hardening check.

        Args:
            target: IP address to check (must be RFC 1918).
            port: SSH port number.
            on_progress: Optional async callback for terminal-style output.

        Returns:
            List of finding dicts for SSH hardening issues.
        """
        async def emit(msg: str):
            if on_progress:
                await on_progress(msg)

        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges. Action aborted.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8) are permitted.",
            }]

        logger.info("Starting SSH hardening check", target=target, port=port)
        await emit(f"$ ssh -v -o BatchMode=yes {target} -p {port}")
        findings = []

        # Phase 1: Get SSH banner
        await emit("Fetching SSH banner...")
        banner = await self._get_banner(target, port)
        if not banner:
            await emit(f"  No response from {target}:{port}")
            return [{
                "title": f"SSH service on port {port} not responding",
                "severity": "info",
                "category": "info",
                "description": f"Could not connect to SSH service on {target}:{port} or no banner received.",
                "evidence": "Connection failed or timeout",
                "remediation": "Verify the SSH service is running and accessible.",
            }]

        await emit(f"  Banner: {banner[:80]}")
        findings.append({
            "title": f"SSH service detected: {banner[:80]}",
            "severity": "info",
            "category": "info",
            "description": f"SSH server banner: {banner}",
            "evidence": f"Banner: {banner}",
            "remediation": None,
        })

        # Phase 2: Analyze banner for version issues
        await emit("Analyzing banner for version issues...")
        banner_findings = self._analyze_banner(banner)
        for f in banner_findings:
            await emit(f"  {f.get('severity', 'info').upper()}: {f['title']}")
        findings.extend(banner_findings)

        # Phase 3: Check algorithms via paramiko
        await emit("Checking KEX, cipher, and MAC algorithms...")
        try:
            algo_findings = await self._check_algorithms(target, port)
            for f in algo_findings:
                await emit(f"  {f.get('severity', 'info').upper()}: {f['title']}")
            findings.extend(algo_findings)
        except Exception as e:
            await emit(f"  Algorithm check skipped: {e}")
            logger.debug("Algorithm check failed", error=str(e))

        # Phase 4: Check auth methods and root login
        await emit("Checking authentication methods...")
        try:
            auth_findings = await self._check_auth_and_root(target, port)
            for f in auth_findings:
                await emit(f"  {f.get('severity', 'info').upper()}: {f['title']}")
            findings.extend(auth_findings)
        except Exception as e:
            await emit(f"  Auth check skipped: {e}")
            logger.debug("Auth method check failed", error=str(e))

        await emit(f"SSH hardening check complete â€” {len(findings)} findings")
        logger.info("SSH hardening check complete", target=target, finding_count=len(findings))
        return findings

    def _analyze_banner(self, banner: str) -> list[dict]:
        """Analyze SSH banner for version and protocol issues."""
        findings = []
        banner_lower = banner.lower()

        # Check for SSH protocol v1
        if "ssh-1" in banner_lower and "ssh-2" not in banner_lower:
            findings.append({
                "title": "SSH protocol version 1 detected",
                "severity": "critical",
                "category": "vuln",
                "description": "SSH v1 has known cryptographic weaknesses and should not be used.",
                "evidence": f"Banner indicates SSH v1: {banner}",
                "remediation": "Disable SSH v1 and use only SSH v2.",
            })

        # Check for OpenSSH version
        if "openssh" in banner_lower:
            version = self._extract_openssh_version(banner)
            if version:
                findings.append({
                    "title": f"OpenSSH version: {version}",
                    "severity": "info",
                    "category": "info",
                    "description": f"OpenSSH {version} detected. Check for known CVEs for this version.",
                    "evidence": f"Version: {version}",
                    "remediation": None,
                })
                # Check for notably old versions
                try:
                    major, minor_str = version.split(".")[:2]
                    major_int = int(major)
                    minor_int = int(minor_str.split("p")[0])
                    if major_int < 7 or (major_int == 7 and minor_int < 4):
                        findings.append({
                            "title": f"Outdated OpenSSH version {version}",
                            "severity": "high",
                            "category": "vuln",
                            "description": f"OpenSSH {version} is significantly outdated and may contain known vulnerabilities.",
                            "evidence": f"Detected version {version}, recommended >= 8.0",
                            "remediation": "Update OpenSSH to the latest stable version.",
                        })
                except (ValueError, IndexError):
                    pass

        # Check for Dropbear
        if "dropbear" in banner_lower:
            findings.append({
                "title": "Dropbear SSH server detected",
                "severity": "info",
                "category": "info",
                "description": "Dropbear is a lightweight SSH server common on embedded devices and routers.",
                "evidence": f"Banner: {banner}",
                "remediation": "Ensure Dropbear is up to date. Consider OpenSSH for stronger algorithm support.",
            })

        return findings

    def _extract_openssh_version(self, banner: str) -> str | None:
        """Extract OpenSSH version from banner string."""
        match = re.search(r"OpenSSH[_\s](\d+\.\d+(?:p\d+)?)", banner, re.IGNORECASE)
        return match.group(1) if match else None

    async def _get_banner(self, target: str, port: int) -> str | None:
        """Connect and read the SSH banner."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port), timeout=5
            )
            data = await asyncio.wait_for(reader.read(256), timeout=3)
            writer.close()
            await writer.wait_closed()
            return data.decode("utf-8", errors="replace").strip()
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return None

    async def _check_algorithms(self, target: str, port: int) -> list[dict]:
        """Check SSH key exchange, cipher, and MAC algorithms via paramiko."""
        findings = []
        try:
            import paramiko
        except ImportError:
            logger.debug("paramiko not available for SSH algorithm check")
            return findings

        try:
            transport = paramiko.Transport((target, port))
            loop = asyncio.get_event_loop()
            await asyncio.wait_for(
                loop.run_in_executor(None, lambda: transport.connect()),
                timeout=10,
            )

            security_options = transport.get_security_options()

            # Check key exchange algorithms
            kex = set(security_options.kex)
            weak_kex = kex & WEAK_KEY_EXCHANGE
            if weak_kex:
                findings.append({
                    "title": "Weak SSH key exchange algorithms supported",
                    "severity": "medium",
                    "category": "misconfig",
                    "description": f"Server supports weak key exchange: {', '.join(sorted(weak_kex))}",
                    "evidence": f"Weak KEX: {', '.join(sorted(weak_kex))}",
                    "remediation": "Disable weak key exchange algorithms in SSH server configuration (sshd_config KexAlgorithms).",
                })

            # Check cipher algorithms
            ciphers = set(security_options.ciphers)
            weak_c = ciphers & WEAK_CIPHERS
            if weak_c:
                findings.append({
                    "title": "Weak SSH cipher algorithms supported",
                    "severity": "medium",
                    "category": "misconfig",
                    "description": f"Server supports weak ciphers: {', '.join(sorted(weak_c))}",
                    "evidence": f"Weak ciphers: {', '.join(sorted(weak_c))}",
                    "remediation": "Disable weak ciphers. Use AES-CTR or AES-GCM ciphers (sshd_config Ciphers).",
                })

            # Check MAC algorithms
            digests = set(security_options.digests)
            weak_m = digests & WEAK_MACS
            if weak_m:
                findings.append({
                    "title": "Weak SSH MAC algorithms supported",
                    "severity": "low",
                    "category": "misconfig",
                    "description": f"Server supports weak MAC algorithms: {', '.join(sorted(weak_m))}",
                    "evidence": f"Weak MACs: {', '.join(sorted(weak_m))}",
                    "remediation": "Disable weak MACs. Use HMAC-SHA2 or UMAC-128 (sshd_config MACs).",
                })

            # Check host key types
            keys = set(security_options.key_types)
            weak_k = keys & WEAK_HOST_KEYS
            if weak_k:
                findings.append({
                    "title": "Weak SSH host key type: DSA",
                    "severity": "medium",
                    "category": "misconfig",
                    "description": "Server uses DSA host keys which are considered weak.",
                    "evidence": f"Weak host keys: {', '.join(sorted(weak_k))}",
                    "remediation": "Generate ED25519 or RSA (4096-bit) host keys. Remove DSA keys.",
                })

            transport.close()
        except Exception as e:
            logger.debug("SSH algorithm check failed", error=str(e))

        return findings

    async def _check_auth_and_root(self, target: str, port: int) -> list[dict]:
        """Check SSH authentication methods and root login possibility."""
        findings = []
        try:
            import paramiko
        except ImportError:
            logger.debug("paramiko not available for SSH auth check")
            return findings

        try:
            transport = paramiko.Transport((target, port))
            loop = asyncio.get_event_loop()
            await asyncio.wait_for(
                loop.run_in_executor(None, lambda: transport.connect()),
                timeout=10,
            )

            # Check auth methods with empty username
            try:
                transport.auth_none("")
            except paramiko.BadAuthenticationType as e:
                auth_methods = e.allowed_types
                if "password" in auth_methods:
                    findings.append({
                        "title": "SSH password authentication enabled",
                        "severity": "medium",
                        "category": "misconfig",
                        "description": "Password authentication is enabled, which is susceptible to brute-force attacks.",
                        "evidence": f"Allowed auth methods: {', '.join(auth_methods)}",
                        "remediation": "Disable password authentication and use key-based authentication only (sshd_config PasswordAuthentication no).",
                    })
                if "publickey" in auth_methods:
                    findings.append({
                        "title": "SSH public key authentication supported",
                        "severity": "info",
                        "category": "info",
                        "description": "Public key authentication is available (recommended).",
                        "evidence": f"Auth methods: {', '.join(auth_methods)}",
                        "remediation": None,
                    })
            except paramiko.AuthenticationException:
                pass

            transport.close()

            # Check root login possibility via auth_none("root")
            transport2 = paramiko.Transport((target, port))
            await asyncio.wait_for(
                loop.run_in_executor(None, lambda: transport2.connect()),
                timeout=10,
            )
            try:
                transport2.auth_none("root")
                # If this succeeds, auth_none is allowed for root (very bad)
                findings.append({
                    "title": "SSH root login with no authentication",
                    "severity": "critical",
                    "category": "vuln",
                    "description": "Root can log in via SSH without any authentication. This is an extreme security risk.",
                    "evidence": "auth_none('root') succeeded",
                    "remediation": "Disable root login via SSH immediately (sshd_config PermitRootLogin no).",
                })
            except paramiko.BadAuthenticationType as e:
                # Root login is possible but requires authentication
                auth_methods = e.allowed_types
                findings.append({
                    "title": "SSH root login appears possible",
                    "severity": "high",
                    "category": "misconfig",
                    "description": f"Root login is accepted via SSH with methods: {', '.join(auth_methods)}. "
                                   f"Root login should be disabled.",
                    "evidence": f"Root auth methods: {', '.join(auth_methods)}",
                    "remediation": "Disable root login via SSH (sshd_config PermitRootLogin no). Use sudo instead.",
                })
            except paramiko.AuthenticationException:
                # Root login might be disabled
                findings.append({
                    "title": "SSH root login likely restricted",
                    "severity": "info",
                    "category": "info",
                    "description": "Root login via SSH appears to be restricted or disabled.",
                    "evidence": "auth_none('root') raised AuthenticationException",
                    "remediation": None,
                })
            finally:
                transport2.close()

        except Exception as e:
            logger.debug("SSH auth/root check failed", error=str(e))

        return findings

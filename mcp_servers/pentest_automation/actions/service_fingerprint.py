"""Service Fingerprinting action.

Inspired by NeuroSploit's recon_integration and autonomous_scanner â€”
performs deep service and version detection through banner grabbing,
protocol probing, and response analysis across multiple ports.
"""

import asyncio
import ipaddress
import ssl
import re
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

# Protocol probes for different service types
SERVICE_PROBES = {
    21: {
        "name": "FTP",
        "probe": None,  # FTP sends banner on connect
        "patterns": [
            (r"(vsftpd[\s/]+[\d.]+)", "vsftpd"),
            (r"(ProFTPD[\s/]+[\d.]+)", "ProFTPD"),
            (r"(Pure-FTPd)", "Pure-FTPd"),
            (r"(FileZilla Server[\s/]+[\d.]+)", "FileZilla"),
            (r"(220.*FTP)", "FTP Service"),
        ],
    },
    22: {
        "name": "SSH",
        "probe": None,  # SSH sends banner on connect
        "patterns": [
            (r"(OpenSSH[_/][\d.p]+)", "OpenSSH"),
            (r"(dropbear_[\d.]+)", "Dropbear"),
            (r"(SSH-[\d.]+-.*)", "SSH"),
        ],
    },
    23: {
        "name": "Telnet",
        "probe": None,
        "patterns": [
            (r"(BusyBox)", "BusyBox Telnet"),
            (r"(login:)", "Telnet Login"),
            (r"(MikroTik)", "MikroTik RouterOS"),
        ],
    },
    25: {
        "name": "SMTP",
        "probe": None,
        "patterns": [
            (r"(Postfix)", "Postfix"),
            (r"(Exim[\s/]+[\d.]+)", "Exim"),
            (r"(Sendmail[\s/]+[\d.]+)", "Sendmail"),
            (r"(220.*ESMTP)", "SMTP"),
        ],
    },
    53: {
        "name": "DNS",
        "probe": b"\x00\x1e\xb2\x5c\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07version\x04bind\x00\x00\x10\x00\x03",  # version.bind query
        "patterns": [
            (r"(BIND[\s/]+[\d.]+)", "ISC BIND"),
            (r"(dnsmasq-[\d.]+)", "dnsmasq"),
            (r"(PowerDNS)", "PowerDNS"),
            (r"(Unbound[\s/]+[\d.]+)", "Unbound"),
        ],
    },
    80: {
        "name": "HTTP",
        "probe": b"HEAD / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n",
        "patterns": [
            (r"Server:\s*(nginx[/\s][\d.]+)", "nginx"),
            (r"Server:\s*(Apache[/\s][\d.]+)", "Apache"),
            (r"Server:\s*(lighttpd[/\s][\d.]+)", "lighttpd"),
            (r"Server:\s*(Microsoft-IIS[/\s][\d.]+)", "IIS"),
            (r"Server:\s*(openresty[/\s][\d.]+)", "OpenResty"),
            (r"Server:\s*(Caddy)", "Caddy"),
            (r"Server:\s*(gunicorn[/\s][\d.]+)", "Gunicorn"),
            (r"Server:\s*(uvicorn)", "Uvicorn"),
            (r"X-Powered-By:\s*([^\r\n]+)", "Powered-By"),
        ],
    },
    443: {
        "name": "HTTPS",
        "probe": b"HEAD / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n",
        "patterns": [
            (r"Server:\s*(nginx[/\s][\d.]+)", "nginx"),
            (r"Server:\s*(Apache[/\s][\d.]+)", "Apache"),
            (r"Server:\s*(lighttpd[/\s][\d.]+)", "lighttpd"),
            (r"Server:\s*(Microsoft-IIS[/\s][\d.]+)", "IIS"),
        ],
        "tls": True,
    },
    3306: {
        "name": "MySQL",
        "probe": None,
        "patterns": [
            (r"([\d.]+.*MariaDB)", "MariaDB"),
            (r"([\d.]+.*MySQL)", "MySQL"),
            (r"(\x35\.\d)", "MySQL 5.x"),
            (r"(\x38\.\d)", "MySQL 8.x"),
        ],
    },
    5432: {
        "name": "PostgreSQL",
        "probe": None,
        "patterns": [
            (r"(PostgreSQL)", "PostgreSQL"),
        ],
    },
    6379: {
        "name": "Redis",
        "probe": b"INFO server\r\n",
        "patterns": [
            (r"redis_version:([\d.]+)", "Redis"),
        ],
    },
    8080: {
        "name": "HTTP Proxy",
        "probe": b"HEAD / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n",
        "patterns": [
            (r"Server:\s*([^\r\n]+)", "HTTP Server"),
        ],
    },
    8443: {
        "name": "HTTPS Alt",
        "probe": b"HEAD / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n",
        "patterns": [
            (r"Server:\s*([^\r\n]+)", "HTTPS Server"),
        ],
        "tls": True,
    },
    9090: {
        "name": "Management",
        "probe": b"HEAD / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n",
        "patterns": [
            (r"Server:\s*([^\r\n]+)", "Mgmt Server"),
            (r"(Cockpit)", "Cockpit"),
            (r"(Webmin)", "Webmin"),
        ],
    },
    1883: {
        "name": "MQTT",
        "probe": b"\x10\x0e\x00\x04MQTT\x04\x02\x00\x3c\x00\x02id",
        "patterns": [
            (r"(MQTT)", "MQTT Broker"),
            (r"(mosquitto)", "Mosquitto"),
        ],
    },
}


def _is_in_scope(target: str) -> bool:
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class ServiceFingerprintAction:
    """Deep service fingerprinting via banner grabbing and protocol probing.

    Probes common service ports with protocol-specific requests and
    analyzes responses to identify software, versions, and potential
    security issues. Based on NeuroSploit's recon_integration module.
    """

    action_id = "service_fingerprint"
    name = "Service Fingerprinting"
    description = "Deep service and version detection via banner grabbing and protocol probing across 15 service types."
    risk_level = "low"
    category = "neurosploit"

    async def execute(self, target: str, ports: list[int] | None = None) -> list[dict]:
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs are permitted.",
            }]

        check_ports = ports or list(SERVICE_PROBES.keys())
        logger.info("Starting service fingerprinting", target=target, ports=check_ports)

        findings = []
        services_found = []
        semaphore = asyncio.Semaphore(10)

        tasks = [
            self._probe_service(target, port, semaphore)
            for port in check_ports
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for port, result in zip(check_ports, results):
            if isinstance(result, Exception):
                continue
            if result is None:
                continue

            service_name, version_info, banner, is_tls = result
            services_found.append((port, service_name, version_info))

            # Check for security issues
            severity = "info"
            category = "info"
            remediation = None

            # Outdated/dangerous services
            if port == 23:
                severity = "high"
                category = "exposure"
                remediation = "Disable Telnet and use SSH instead. Telnet transmits all data in cleartext."
            elif port == 21:
                severity = "medium"
                category = "exposure"
                remediation = "Consider using SFTP instead of FTP for encrypted file transfers."
            elif port == 6379 and banner and "noauth" not in banner.lower():
                severity = "high"
                category = "exposure"
                remediation = "Redis should not be exposed on the network. Bind to localhost and enable AUTH."
            elif port == 3306 or port == 5432:
                severity = "medium"
                category = "exposure"
                remediation = f"Database service on port {port} should not be directly accessible. Use a firewall or bind to localhost."

            # Version disclosure
            if version_info and version_info != service_name:
                version_finding_severity = "low"
                if any(old in version_info.lower() for old in ["5.7", "5.6", "5.5", "2.2.", "1.18", "1.0."]):
                    version_finding_severity = "medium"

                findings.append({
                    "title": f"Service version disclosed: {version_info} on port {port}",
                    "severity": version_finding_severity,
                    "category": "exposure",
                    "description": f"Service {service_name} on port {port} reveals version information: {version_info}. This helps attackers identify specific CVEs.",
                    "evidence": f"Port: {port}/{service_name}\nVersion: {version_info}\nBanner: {banner[:200] if banner else 'N/A'}",
                    "remediation": "Suppress version information in service banners where possible.",
                })

            if severity != "info" or (severity == "info" and category == "info"):
                findings.append({
                    "title": f"{service_name} service detected on port {port}" + (f" ({version_info})" if version_info else ""),
                    "severity": severity,
                    "category": category,
                    "description": f"{'TLS-wrapped ' if is_tls else ''}{service_name} service identified on {target}:{port}.",
                    "evidence": f"Port: {port}\nService: {service_name}\nVersion: {version_info or 'Unknown'}\nTLS: {'Yes' if is_tls else 'No'}\nBanner: {banner[:300] if banner else 'N/A'}",
                    "remediation": remediation,
                })

        if not services_found:
            findings.append({
                "title": f"No services detected on {target}",
                "severity": "info",
                "category": "info",
                "description": f"None of the {len(check_ports)} probed ports responded.",
                "evidence": f"Ports tested: {', '.join(str(p) for p in check_ports)}",
                "remediation": "No action required.",
            })

        logger.info("Service fingerprinting complete", target=target, services=len(services_found))
        return findings

    async def _probe_service(
        self, target: str, port: int, semaphore: asyncio.Semaphore
    ) -> tuple[str, str | None, str | None, bool] | None:
        """Probe a single port and try to fingerprint the service."""
        probe_info = SERVICE_PROBES.get(port, {
            "name": f"Unknown ({port})",
            "probe": None,
            "patterns": [],
        })

        async with semaphore:
            try:
                use_tls = probe_info.get("tls", False)

                if use_tls:
                    ctx = ssl.create_default_context()
                    ctx.check_hostname = False
                    ctx.verify_mode = ssl.CERT_NONE
                    reader, writer = await asyncio.wait_for(
                        asyncio.open_connection(target, port, ssl=ctx), timeout=6
                    )
                else:
                    reader, writer = await asyncio.wait_for(
                        asyncio.open_connection(target, port), timeout=6
                    )

                # Send probe if defined, otherwise just read banner
                if probe_info.get("probe"):
                    writer.write(probe_info["probe"])
                    await writer.drain()

                data = await asyncio.wait_for(reader.read(4096), timeout=5)
                banner = data.decode("utf-8", errors="replace").strip()
                writer.close()
                await writer.wait_closed()

                if not banner:
                    return probe_info["name"], None, None, use_tls

                # Try to match patterns
                for pattern, product_name in probe_info.get("patterns", []):
                    match = re.search(pattern, banner, re.IGNORECASE)
                    if match:
                        version = match.group(1).strip()
                        return probe_info["name"], version, banner, use_tls

                return probe_info["name"], None, banner[:500], use_tls

            except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
                return None

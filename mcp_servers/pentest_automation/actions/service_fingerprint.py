"""Service Fingerprint action â€” NeuroSploit-derived.

Detects technology stack from HTTP responses: CMS (WordPress, Joomla,
Drupal), frameworks (React, Angular, Vue, Django, Rails, etc.), servers
(Apache, Nginx, IIS, etc.), and languages (PHP, Python, Node.js, etc.).
"""

import asyncio
import re
import structlog

from mcp_servers.pentest_automation.actions.neurosploit_utils import (
    is_in_scope,
    out_of_scope_finding,
    confidence_score,
    async_http_request,
)

logger = structlog.get_logger()

# CMS detection: (name, probe_paths, meta_patterns, body_patterns)
CMS_SIGNATURES = [
    {
        "name": "WordPress",
        "probe_paths": ["/wp-login.php", "/wp-includes/js/wp-embed.min.js"],
        "meta_patterns": [r'<meta name="generator" content="wordpress'],
        "body_patterns": [r"/wp-content/", r"/wp-includes/", r"wp-json"],
    },
    {
        "name": "Joomla",
        "probe_paths": ["/administrator/", "/media/system/js/core.js"],
        "meta_patterns": [r'<meta name="generator" content="joomla'],
        "body_patterns": [r"/media/jui/", r"/components/com_", r"joomla!"],
    },
    {
        "name": "Drupal",
        "probe_paths": ["/core/misc/drupal.js", "/misc/drupal.js"],
        "meta_patterns": [r'<meta name="generator" content="drupal'],
        "body_patterns": [r"drupal\.settings", r"/sites/default/files/", r"drupal\.js"],
    },
]

# Framework detection: (name, patterns_in_body)
FRAMEWORK_PATTERNS = {
    "React": [r"react\.production\.min\.js", r"__react", r"data-reactroot", r"_reactRootContainer"],
    "Angular": [r"ng-version=", r"angular\.min\.js", r"ng-app=", r"angular\.io"],
    "Vue.js": [r"vue\.min\.js", r"vue\.runtime", r"data-v-[a-f0-9]+", r"__vue__"],
    "jQuery": [r"jquery[\.-][\d.]+\.min\.js", r"jquery\.min\.js"],
    "Django": [r"csrfmiddlewaretoken", r"__admin/", r"django\.contrib"],
    "Ruby on Rails": [r"csrf-token.*?authenticity_token", r"data-turbolinks", r"action_controller"],
    "Express": [r"x-powered-by.*?express"],
    "ASP.NET": [r"__viewstate", r"__eventvalidation", r"asp\.net", r"\.aspx"],
    "Laravel": [r"laravel_session", r"csrf-token.*?content", r"laravel"],
    "Spring": [r"jsessionid", r"spring\.", r"org\.springframework"],
}

# Server detection: (name, header_patterns, version_regex)
SERVER_SIGNATURES = {
    "Apache": {"patterns": ["apache"], "version_re": r"apache[/ ]([\d.]+)"},
    "Nginx": {"patterns": ["nginx"], "version_re": r"nginx[/ ]([\d.]+)"},
    "IIS": {"patterns": ["microsoft-iis"], "version_re": r"microsoft-iis[/ ]([\d.]+)"},
    "LiteSpeed": {"patterns": ["litespeed"], "version_re": r"litespeed[/ ]?([\d.]+)?"},
    "Caddy": {"patterns": ["caddy"], "version_re": r"caddy[/ ]?([\d.]+)?"},
    "Tomcat": {"patterns": ["apache-coyote", "tomcat"], "version_re": r"(?:tomcat|coyote)[/ ]([\d.]+)"},
}

# Language detection from headers and body
LANGUAGE_SIGNATURES = {
    "PHP": {
        "headers": {"x-powered-by": ["php"]},
        "body": [r"\.php", r"phpsessid"],
    },
    "Python": {
        "headers": {"x-powered-by": ["python", "gunicorn", "uvicorn", "werkzeug"]},
        "body": [r"wsgi", r"python"],
    },
    "Node.js": {
        "headers": {"x-powered-by": ["express", "node", "koa", "next"]},
        "body": [r"node_modules"],
    },
    "Java": {
        "headers": {"x-powered-by": ["servlet", "jsp", "java"]},
        "body": [r"jsessionid", r"\.jsp", r"java\.lang"],
    },
    ".NET": {
        "headers": {"x-powered-by": ["asp.net"], "x-aspnet-version": [""]},
        "body": [r"\.aspx", r"__viewstate"],
    },
    "Ruby": {
        "headers": {"x-powered-by": ["phusion passenger", "puma", "unicorn"]},
        "body": [r"\.rb", r"ruby"],
    },
}


class ServiceFingerprintAction:
    """Fingerprint web service technology stack via passive analysis."""

    action_id = "service_fingerprint"
    name = "Service Fingerprint"
    description = "Detect CMS, frameworks, web servers, and programming languages from HTTP responses."
    risk_level = "low"

    async def execute(self, target: str, port: int = 80, use_tls: bool = False, on_progress=None) -> list[dict]:
        if not is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [out_of_scope_finding(target)]

        async def emit(msg: str):
            if on_progress:
                await on_progress(msg)

        logger.info("Starting service fingerprint", target=target, port=port, tls=use_tls)

        # Fetch the main page
        await emit("Fetching HTTP response...")
        status, headers, body = await async_http_request(
            target, port, "/", use_tls=use_tls, max_read=32768,
        )

        if status is None:
            return [{
                "title": f"Service fingerprint: No HTTP response from {target}:{port}",
                "severity": "info",
                "category": "info",
                "description": f"Could not connect to {target}:{port} for fingerprinting.",
                "evidence": "Connection failed.",
                "remediation": "Verify the service is running and accessible.",
            }]

        body_lower = body.lower() if body else ""
        findings = []

        # Run detection categories concurrently
        await emit("Detecting CMS...")
        cms_task = self._detect_cms(target, port, use_tls, body_lower)
        await emit("Fingerprinting frameworks...")
        framework_findings = self._detect_frameworks(body_lower, headers)
        await emit("Identifying server software...")
        server_findings = self._detect_server(headers)
        await emit("Detecting programming languages...")
        language_findings = self._detect_languages(headers, body_lower)

        cms_findings = await cms_task

        findings.extend(cms_findings)
        findings.extend(framework_findings)
        findings.extend(server_findings)
        findings.extend(language_findings)

        # Summary finding
        tech_names = [f.get("technology", f["title"]) for f in findings if f["severity"] != "info"]
        if tech_names:
            findings.insert(0, {
                "title": f"Technology stack identified on {target}:{port}",
                "severity": "info",
                "category": "recon",
                "description": f"Detected technologies: {', '.join(tech_names)}.",
                "evidence": f"Total technologies detected: {len(tech_names)}",
                "remediation": "Review detected technologies for known vulnerabilities and keep them updated.",
            })
        else:
            findings.append({
                "title": f"No technology fingerprints detected on {target}:{port}",
                "severity": "info",
                "category": "info",
                "description": "Could not identify specific technologies from HTTP responses.",
                "evidence": f"HTTP {status}, headers and body analyzed",
                "remediation": "No action required.",
            })

        logger.info("Service fingerprint complete", target=target, findings=len(findings))
        return findings

    async def _detect_cms(self, target: str, port: int, use_tls: bool, body_lower: str) -> list[dict]:
        """Detect CMS platforms via path probes, meta tags, and body patterns."""
        findings = []

        for cms in CMS_SIGNATURES:
            signals = []

            # Check meta generator and body patterns (from already-fetched page)
            for pattern in cms["meta_patterns"]:
                if re.search(pattern, body_lower):
                    signals.append(f"meta_generator:{cms['name']}")

            for pattern in cms["body_patterns"]:
                if re.search(pattern, body_lower):
                    signals.append(f"body:{pattern[:30]}")

            # Probe CMS-specific paths
            tasks = [
                async_http_request(target, port, path, use_tls=use_tls, timeout=6)
                for path in cms["probe_paths"]
            ]
            results = await asyncio.gather(*tasks, return_exceptions=True)

            for path, result in zip(cms["probe_paths"], results):
                if isinstance(result, Exception):
                    continue
                status, _, _ = result
                if status is not None and status == 200:
                    signals.append(f"path:{path}")

            if signals:
                conf = confidence_score(len(signals), 5, has_evidence=True, fp_risk=0.1)
                findings.append({
                    "title": f"CMS detected: {cms['name']}",
                    "severity": "low",
                    "category": "recon",
                    "description": f"{cms['name']} CMS detected with {len(signals)} signal(s). Confidence: {conf}%.",
                    "evidence": f"Signals: {signals}",
                    "remediation": f"Keep {cms['name']} and all plugins updated. Remove default files in production.",
                    "confidence": conf,
                    "technology": cms["name"],
                })

        return findings

    def _detect_frameworks(self, body_lower: str, headers: dict[str, str]) -> list[dict]:
        """Detect frontend and backend frameworks."""
        findings = []
        all_text = body_lower + " " + " ".join(f"{k}: {v}" for k, v in headers.items()).lower()

        for framework, patterns in FRAMEWORK_PATTERNS.items():
            matched = []
            for pattern in patterns:
                if re.search(pattern, all_text):
                    matched.append(pattern[:30])

            if matched:
                conf = confidence_score(len(matched), len(patterns), has_evidence=True, fp_risk=0.2)
                findings.append({
                    "title": f"Framework detected: {framework}",
                    "severity": "info",
                    "category": "recon",
                    "description": f"{framework} framework detected with {len(matched)} pattern match(es). Confidence: {conf}%.",
                    "evidence": f"Matched patterns: {matched}",
                    "remediation": f"Ensure {framework} is updated to the latest version.",
                    "confidence": conf,
                    "technology": framework,
                })

        return findings

    def _detect_server(self, headers: dict[str, str]) -> list[dict]:
        """Detect web server software and extract version."""
        findings = []
        server_header = headers.get("server", "").lower()
        if not server_header:
            return findings

        for server_name, sig in SERVER_SIGNATURES.items():
            for pattern in sig["patterns"]:
                if pattern in server_header:
                    version = None
                    version_match = re.search(sig["version_re"], server_header)
                    if version_match:
                        version = version_match.group(1)

                    version_str = f" version {version}" if version else ""
                    findings.append({
                        "title": f"Web server: {server_name}{version_str}",
                        "severity": "low",
                        "category": "recon",
                        "description": f"{server_name}{version_str} detected via Server header.",
                        "evidence": f"Server: {headers.get('server', '')}",
                        "remediation": f"Suppress version information from Server header. Keep {server_name} updated.",
                        "confidence": confidence_score(1, 1, has_evidence=True, fp_risk=0.05),
                        "technology": server_name,
                        "version": version,
                    })
                    return findings  # One server match is enough

        return findings

    def _detect_languages(self, headers: dict[str, str], body_lower: str) -> list[dict]:
        """Detect programming languages from headers and body patterns."""
        findings = []

        for lang, sig in LANGUAGE_SIGNATURES.items():
            signals = []

            # Header-based detection
            for header_name, patterns in sig.get("headers", {}).items():
                header_val = headers.get(header_name, "").lower()
                if header_val:
                    if not patterns or patterns == [""]:
                        signals.append(f"header:{header_name}")
                    else:
                        for pat in patterns:
                            if pat and pat in header_val:
                                signals.append(f"header:{header_name}={pat}")

            # Body-based detection
            for pattern in sig.get("body", []):
                if re.search(pattern, body_lower):
                    signals.append(f"body:{pattern}")

            if signals:
                conf = confidence_score(len(signals), 3, has_evidence=True, fp_risk=0.25)
                findings.append({
                    "title": f"Language detected: {lang}",
                    "severity": "info",
                    "category": "recon",
                    "description": f"{lang} detected with {len(signals)} signal(s). Confidence: {conf}%.",
                    "evidence": f"Signals: {signals}",
                    "remediation": f"Ensure {lang} runtime is updated and version info is not publicly exposed.",
                    "confidence": conf,
                    "technology": lang,
                })

        return findings

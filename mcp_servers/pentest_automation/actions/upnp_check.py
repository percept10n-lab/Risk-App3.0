import asyncio
import ipaddress
import socket
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

SSDP_MSEARCH = (
    "M-SEARCH * HTTP/1.1\r\n"
    "HOST: 239.255.255.250:1900\r\n"
    'MAN: "ssdp:discover"\r\n'
    "MX: 3\r\n"
    "ST: ssdp:all\r\n"
    "\r\n"
)


def _is_in_scope(target: str) -> bool:
    """Validate that target IP is within RFC 1918 private ranges."""
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class UPnPCheckAction:
    """Check for UPnP/SSDP exposure on target devices.

    Sends SSDP M-SEARCH probes to detect UPnP services, parses device
    capabilities, and checks for port forwarding exposure.
    """

    action_id = "upnp_check"
    name = "UPnP/SSDP Exposure Check"
    description = "Detect UPnP services, parse capabilities, and check for port forwarding exposure."
    risk_level = "low"

    async def execute(self, target: str, on_progress=None) -> list[dict]:
        """Execute UPnP exposure check.

        Args:
            target: IP address to check (must be RFC 1918).
            on_progress: Optional async callback for terminal-style output.

        Returns:
            List of finding dicts for UPnP exposure issues.
        """
        async def emit(msg: str):
            if on_progress:
                await on_progress(msg)

        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges. Action aborted.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8) are permitted.",
            }]

        logger.info("Starting UPnP check", target=target)
        await emit(f"$ gssdp-discover --target={target} --timeout=5")
        await emit(f"Sending SSDP M-SEARCH to {target}:1900...")
        findings = []

        # Phase 1: Send SSDP M-SEARCH directly to target
        ssdp_responses = await self._send_ssdp_unicast(target)

        if not ssdp_responses:
            await emit(f"  No SSDP response from {target} â€” UPnP likely disabled")
            findings.append({
                "title": f"No UPnP/SSDP response from {target}",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} did not respond to SSDP M-SEARCH probe. UPnP may be disabled.",
                "evidence": "No SSDP response received within timeout",
                "remediation": "No action required if UPnP is intentionally disabled.",
            })
            logger.info("UPnP check complete, no response", target=target)
            return findings

        await emit(f"  Received {len(ssdp_responses)} SSDP response(s)")

        # Phase 2: Parse SSDP responses
        devices = self._parse_ssdp_responses(ssdp_responses)
        for device in devices:
            server_info = device.get("server", "Unknown")
            st = device.get("st", "Unknown")
            await emit(f"  Device: {server_info} (ST: {st})")

        findings.append({
            "title": f"UPnP service responding on {target}",
            "severity": "medium",
            "category": "exposure",
            "description": f"Target {target} responded to SSDP M-SEARCH with {len(ssdp_responses)} response(s). "
                           f"UPnP is enabled and may allow unauthorized device control.",
            "evidence": f"SSDP responses: {len(ssdp_responses)}",
            "remediation": "Disable UPnP on the device unless explicitly required. UPnP can allow unauthorized port forwarding.",
        })

        # Report discovered device types and services
        for device in devices:
            server_info = device.get("server", "Unknown")
            location = device.get("location", "Unknown")
            st = device.get("st", "Unknown")

            findings.append({
                "title": f"UPnP device: {server_info}",
                "severity": "info",
                "category": "exposure",
                "description": f"UPnP device advertising service type '{st}' with description at {location}.",
                "evidence": f"Server: {server_info}, Location: {location}, ST: {st}",
                "remediation": "Review if this UPnP service is necessary. Disable unnecessary services.",
            })

        # Phase 3: Check for IGD (Internet Gateway Device) - port forwarding capable
        igd_devices = [d for d in devices if "igd" in d.get("st", "").lower()
                       or "wanipconnection" in d.get("st", "").lower()
                       or "wanpppconnection" in d.get("st", "").lower()]

        if igd_devices:
            findings.append({
                "title": "UPnP Internet Gateway Device (IGD) detected",
                "severity": "high",
                "category": "exposure",
                "description": "Target exposes UPnP IGD service which allows any local application to create "
                               "port forwarding rules. Malware can use this to expose internal services to the internet.",
                "evidence": f"IGD service types: {[d.get('st') for d in igd_devices]}",
                "remediation": "Disable UPnP IGD on the router/gateway. Use manual port forwarding rules instead.",
            })

        # Phase 4: Try to fetch device description for more details
        for device in devices:
            location = device.get("location")
            if location:
                desc_findings = await self._fetch_device_description(location, target)
                findings.extend(desc_findings)
                break  # Only check the first location to limit requests

        logger.info("UPnP check complete", target=target, finding_count=len(findings))
        return findings

    async def _send_ssdp_unicast(self, target: str) -> list[str]:
        """Send SSDP M-SEARCH directly to target and collect responses."""
        responses = []
        loop = asyncio.get_event_loop()

        try:
            result = await asyncio.wait_for(
                loop.run_in_executor(None, self._ssdp_unicast_sync, target),
                timeout=8,
            )
            responses = result
        except asyncio.TimeoutError:
            logger.debug("SSDP unicast timeout", target=target)
        except Exception as e:
            logger.debug("SSDP unicast failed", target=target, error=str(e))

        return responses

    def _ssdp_unicast_sync(self, target: str) -> list[str]:
        """Synchronous SSDP unicast probe."""
        responses = []
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(5)

        try:
            sock.sendto(SSDP_MSEARCH.encode(), (target, 1900))

            # Collect multiple responses
            while True:
                try:
                    data, addr = sock.recvfrom(4096)
                    if addr[0] == target:
                        responses.append(data.decode("utf-8", errors="replace"))
                except socket.timeout:
                    break
        except OSError as e:
            logger.debug("SSDP send failed", target=target, error=str(e))
        finally:
            sock.close()

        return responses

    def _parse_ssdp_responses(self, responses: list[str]) -> list[dict]:
        """Parse SSDP response headers into structured device info."""
        devices = []
        for response in responses:
            device = {}
            lines = response.split("\r\n")
            for line in lines:
                if ":" in line:
                    key, _, value = line.partition(":")
                    key_lower = key.strip().lower()
                    device[key_lower] = value.strip()
            if device:
                devices.append(device)
        return devices

    async def _fetch_device_description(self, location: str, target: str) -> list[dict]:
        """Try to fetch and parse UPnP device description XML."""
        findings = []

        # Extract host and port from location URL
        try:
            # location is like http://192.168.1.1:5000/description.xml
            if not location.startswith("http"):
                return findings
            parts = location.replace("http://", "").replace("https://", "").split("/", 1)
            host_port = parts[0]
            path = "/" + parts[1] if len(parts) > 1 else "/"

            if ":" in host_port:
                host, port_str = host_port.split(":", 1)
                port = int(port_str)
            else:
                host = host_port
                port = 80

            # Only fetch from the target IP to stay in scope
            if host != target:
                return findings

            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=5
            )

            request = (
                f"GET {path} HTTP/1.1\r\n"
                f"Host: {host_port}\r\n"
                f"Connection: close\r\n"
                f"User-Agent: RiskPlatform-Pentest/1.0\r\n"
                f"\r\n"
            )
            writer.write(request.encode())
            await writer.drain()

            data = await asyncio.wait_for(reader.read(8192), timeout=5)
            body = data.decode("utf-8", errors="replace")
            writer.close()
            await writer.wait_closed()

            # Simple XML element extraction without full parser
            model_name = self._extract_xml_value(body, "modelName")
            friendly_name = self._extract_xml_value(body, "friendlyName")
            manufacturer = self._extract_xml_value(body, "manufacturer")
            device_type = self._extract_xml_value(body, "deviceType")

            if friendly_name or model_name:
                findings.append({
                    "title": f"UPnP device identified: {friendly_name or model_name}",
                    "severity": "info",
                    "category": "exposure",
                    "description": (
                        f"Device: {friendly_name or 'N/A'}, Model: {model_name or 'N/A'}, "
                        f"Manufacturer: {manufacturer or 'N/A'}, Type: {device_type or 'N/A'}"
                    ),
                    "evidence": f"Description fetched from {location}",
                    "remediation": "Ensure device firmware is up to date. Disable UPnP if not required.",
                })

            # Check for WANIPConnection or WANPPPConnection services (port forwarding)
            if "wanipconnection" in body.lower() or "wanpppconnection" in body.lower():
                findings.append({
                    "title": "UPnP port forwarding capability detected",
                    "severity": "high",
                    "category": "exposure",
                    "description": "Device description includes WANIPConnection or WANPPPConnection services, "
                                   "which allow automated port forwarding. Malware can abuse this.",
                    "evidence": f"Port forwarding service found in {location}",
                    "remediation": "Disable UPnP port forwarding on the gateway device.",
                })

        except (asyncio.TimeoutError, ConnectionRefusedError, OSError, ValueError) as e:
            logger.debug("Device description fetch failed", location=location, error=str(e))

        return findings

    @staticmethod
    def _extract_xml_value(xml: str, tag: str) -> str | None:
        """Extract value from a simple XML tag (no namespace handling)."""
        import re
        # Match with or without namespace prefix
        pattern = rf"<(?:\w+:)?{tag}[^>]*>(.*?)</(?:\w+:)?{tag}>"
        match = re.search(pattern, xml, re.IGNORECASE | re.DOTALL)
        return match.group(1).strip() if match else None

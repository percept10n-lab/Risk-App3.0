"""Shared utilities for NeuroSploit-derived pentest actions.

Centralizes scope validation, confidence scoring, raw HTTP helpers,
and WAF signature data used across waf_detect, web_vuln_probe,
service_fingerprint, and exploit_chain actions.
"""

import asyncio
import ipaddress
import ssl
import structlog

logger = structlog.get_logger()

# ---------------------------------------------------------------------------
# Scope validation (replaces per-action duplication)
# ---------------------------------------------------------------------------
RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]


def is_in_scope(target: str) -> bool:
    """Validate that target IP is within RFC 1918 private ranges."""
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


def out_of_scope_finding(target: str) -> dict:
    """Return a standard out-of-scope finding dict."""
    return {
        "title": "Target out of scope",
        "severity": "info",
        "category": "info",
        "description": f"Target {target} is not within allowed RFC 1918 ranges. Action aborted.",
        "evidence": f"Target IP: {target}",
        "remediation": "Only RFC 1918 private IPs (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8) are permitted.",
    }


# ---------------------------------------------------------------------------
# Confidence scoring
# ---------------------------------------------------------------------------
def confidence_score(
    positive: int,
    total: int,
    has_evidence: bool = True,
    fp_risk: float = 0.0,
) -> int:
    """Calculate a 0-100 confidence score for a finding.

    Args:
        positive: Number of positive signals matched.
        total: Total signals checked.
        has_evidence: Whether concrete evidence (not just heuristic) exists.
        fp_risk: False-positive risk factor 0.0-1.0 (subtracted from score).

    Returns:
        Integer confidence score clamped to 0-100.
    """
    if total == 0:
        return 0
    ratio = positive / total
    base = ratio * 80  # max 80 from signal ratio
    evidence_bonus = 20 if has_evidence else 0
    penalty = fp_risk * 30
    return max(0, min(100, int(base + evidence_bonus - penalty)))


# ---------------------------------------------------------------------------
# Async HTTP helper (raw sockets, same pattern as http_headers.py)
# ---------------------------------------------------------------------------
async def async_http_request(
    target: str,
    port: int,
    path: str = "/",
    method: str = "GET",
    use_tls: bool = False,
    headers: dict[str, str] | None = None,
    body: str | None = None,
    timeout: float = 10,
    max_read: int = 16384,
) -> tuple[int | None, dict[str, str], str]:
    """Send a raw HTTP request and return (status_code, headers_dict, body).

    Returns (None, {}, "") on connection failure.
    """
    try:
        if use_tls:
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port, ssl=ctx), timeout=timeout
            )
        else:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port), timeout=timeout
            )

        extra_headers = headers or {}
        header_lines = "".join(f"{k}: {v}\r\n" for k, v in extra_headers.items())

        content_length = ""
        if body:
            content_length = f"Content-Length: {len(body.encode())}\r\n"

        request = (
            f"{method} {path} HTTP/1.1\r\n"
            f"Host: {target}\r\n"
            f"Connection: close\r\n"
            f"User-Agent: RiskPlatform-Pentest/1.0\r\n"
            f"{header_lines}"
            f"{content_length}"
            f"\r\n"
        )
        if body:
            request += body

        writer.write(request.encode())
        await writer.drain()

        data = await asyncio.wait_for(reader.read(max_read), timeout=timeout)
        response = data.decode("utf-8", errors="replace")
        writer.close()
        await writer.wait_closed()

        # Parse status line
        lines = response.split("\r\n")
        status_code = None
        resp_headers: dict[str, str] = {}

        if lines:
            parts = lines[0].split(" ", 2)
            if len(parts) >= 2:
                try:
                    status_code = int(parts[1])
                except ValueError:
                    pass

        # Parse headers and body
        body_start = False
        body_lines = []
        for line in lines[1:]:
            if body_start:
                body_lines.append(line)
            elif line == "":
                body_start = True
            else:
                if ":" in line:
                    key, _, value = line.partition(":")
                    resp_headers[key.strip().lower()] = value.strip()

        resp_body = "\n".join(body_lines)
        return status_code, resp_headers, resp_body

    except (asyncio.TimeoutError, ConnectionRefusedError, OSError, ssl.SSLError) as e:
        logger.debug("HTTP request failed", target=target, port=port, path=path, error=str(e))
        return None, {}, ""


# ---------------------------------------------------------------------------
# WAF Signatures â€” 16 WAF vendors
# Each entry: {"headers": {header: [patterns]}, "body": [patterns], "cookies": [patterns]}
# ---------------------------------------------------------------------------
WAF_SIGNATURES: dict[str, dict] = {
    "cloudflare": {
        "headers": {"server": ["cloudflare"], "cf-ray": [""]},
        "body": ["attention required! | cloudflare", "cloudflare ray id", "error 1020"],
        "cookies": ["__cfduid", "__cf_bm", "cf_clearance"],
    },
    "aws_waf": {
        "headers": {"x-amzn-requestid": [""], "x-amz-cf-id": [""]},
        "body": ["request blocked", "automated access to this page"],
        "cookies": ["awsalb", "awsalbcors"],
    },
    "akamai": {
        "headers": {"server": ["akamaighost", "akamai"], "x-akamai-transformed": [""]},
        "body": ["access denied", "reference #"],
        "cookies": ["akamai", "ak_bmsc", "bm_sz"],
    },
    "imperva": {
        "headers": {"x-iinfo": [""], "x-cdn": ["imperva", "incapsula"]},
        "body": ["incapsula incident id", "powered by incapsula", "_incapsula_resource"],
        "cookies": ["visid_incap_", "incap_ses_", "nlbi_"],
    },
    "f5_bigip": {
        "headers": {"server": ["bigip", "big-ip"], "x-wa-info": [""]},
        "body": ["the requested url was rejected", "please consult with your administrator"],
        "cookies": ["ts", "bigipserver", "f5_cspm"],
    },
    "barracuda": {
        "headers": {"server": ["barracuda"]},
        "body": ["you have been blocked", "barracuda networks"],
        "cookies": ["barra_counter_session", "bni__barranet"],
    },
    "fortinet": {
        "headers": {"server": ["fortiweb"]},
        "body": ["fortigate", "fortiweb", "the page cannot be displayed", ".fgd_icon"],
        "cookies": ["fortigate", "fortiweb"],
    },
    "modsecurity": {
        "headers": {"server": ["mod_security", "modsecurity"]},
        "body": ["mod_security", "modsecurity", "not acceptable", "method not implemented"],
        "cookies": [],
    },
    "sucuri": {
        "headers": {"server": ["sucuri"], "x-sucuri-id": [""], "x-sucuri-cache": [""]},
        "body": ["sucuri website firewall", "access denied - sucuri", "cloudproxy"],
        "cookies": ["sucuri_cloudproxy_uuid"],
    },
    "wordfence": {
        "headers": {},
        "body": ["generated by wordfence", "a potentially unsafe operation has been detected",
                 "your access to this site has been limited"],
        "cookies": ["wfwaf-authcookie"],
    },
    "incapsula": {
        "headers": {"x-cdn": ["incapsula"]},
        "body": ["incapsula incident id", "_incapsula_resource"],
        "cookies": ["visid_incap_", "incap_ses_"],
    },
    "reblaze": {
        "headers": {"server": ["reblaze"]},
        "body": ["access denied (reblaze)", "reblaze"],
        "cookies": ["rbzid"],
    },
    "paloalto": {
        "headers": {"server": ["paloalto", "pan-os"]},
        "body": ["block page", "url filtering", "palo alto networks"],
        "cookies": [],
    },
    "radware": {
        "headers": {"x-sl-compstate": [""]},
        "body": ["unauthorized activity has been detected", "radware"],
        "cookies": [],
    },
    "netscaler": {
        "headers": {"cneonction": [""], "via": ["ns-cache"]},
        "body": ["ns_af_", "citrix", "netscaler"],
        "cookies": ["ns_af_", "citrix_ns_id", "nsc_"],
    },
    "wallarm": {
        "headers": {"server": ["wallarm"]},
        "body": ["wallarm", "request blocked"],
        "cookies": [],
    },
}


# ---------------------------------------------------------------------------
# WAF Bypass Technique Categories
# ---------------------------------------------------------------------------
WAF_BYPASS_TECHNIQUES: dict[str, list[str]] = {
    "encoding": [
        "Double URL encoding",
        "Unicode/UTF-8 encoding",
        "Hex encoding payloads",
        "HTML entity encoding",
    ],
    "request_smuggling": [
        "HTTP request smuggling (CL.TE / TE.CL)",
        "HTTP/2 downgrade smuggling",
        "Chunked transfer encoding manipulation",
    ],
    "payload_mutation": [
        "Case variation (SeLeCt, uNiOn)",
        "Comment insertion (/**/)",
        "Whitespace substitution (tabs, newlines)",
        "Null byte injection",
    ],
    "protocol_abuse": [
        "HTTP parameter pollution",
        "Multipart/form-data boundary manipulation",
        "HTTP method override (X-HTTP-Method-Override)",
    ],
    "evasion": [
        "IP rotation / origin spoofing",
        "Rate limiting avoidance via slow requests",
        "Fragmented payloads across multiple parameters",
    ],
}

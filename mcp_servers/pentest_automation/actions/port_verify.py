import asyncio
import ipaddress
import structlog

logger = structlog.get_logger()

# Top 20 commonly targeted ports
TOP_20_PORTS = [
    21, 22, 23, 25, 53, 80, 110, 111, 135, 139,
    143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080,
]

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]


def _is_in_scope(target: str) -> bool:
    """Validate that target IP is within RFC 1918 private ranges."""
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class PortVerifyAction:
    """Verify specific ports are open using async TCP connect.

    Checks the top 20 common ports by default and returns findings
    for any unexpected open ports discovered.
    """

    action_id = "port_verify"
    name = "Port Verification Scan"
    description = "Verify specific TCP ports are open on a target using async connect probes."
    risk_level = "low"

    async def execute(self, target: str, ports: list[int] | None = None) -> list[dict]:
        """Execute port verification against target.

        Args:
            target: IP address to scan (must be RFC 1918).
            ports: Optional list of ports to check. Defaults to top 20 ports.

        Returns:
            List of finding dicts for open ports discovered.
        """
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges. Action aborted.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8) are permitted.",
            }]

        check_ports = ports if ports is not None else TOP_20_PORTS
        logger.info("Starting port verification", target=target, port_count=len(check_ports))

        findings = []
        open_ports = []

        # Run all port checks concurrently with semaphore to limit concurrency
        semaphore = asyncio.Semaphore(50)
        tasks = [self._check_port(target, port, semaphore) for port in check_ports]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for port, result in zip(check_ports, results):
            if isinstance(result, Exception):
                logger.debug("Port check exception", target=target, port=port, error=str(result))
                continue
            if result:
                open_ports.append(port)

        # Generate findings for open ports
        if open_ports:
            findings.append({
                "title": f"Open ports discovered on {target}",
                "severity": "info",
                "category": "exposure",
                "description": f"Found {len(open_ports)} open port(s) on target: {', '.join(str(p) for p in sorted(open_ports))}.",
                "evidence": f"Open ports: {sorted(open_ports)}",
                "remediation": "Review each open port and close any unnecessary services.",
            })

            # Flag specifically risky open ports
            risky_ports = {
                21: ("FTP", "medium", "FTP transmits credentials in cleartext. Consider SFTP instead."),
                23: ("Telnet", "high", "Telnet transmits all data in cleartext. Use SSH instead."),
                25: ("SMTP", "low", "Open SMTP relay may allow spam. Verify relay restrictions."),
                111: ("RPC", "medium", "RPC portmapper can expose internal service details."),
                135: ("MSRPC", "medium", "Microsoft RPC endpoint mapper can be exploited for enumeration."),
                139: ("NetBIOS", "medium", "NetBIOS session service can leak host information."),
                445: ("SMB", "high", "SMB is a frequent target for lateral movement and ransomware."),
                1723: ("PPTP", "medium", "PPTP VPN uses weak encryption. Consider OpenVPN or WireGuard."),
                3306: ("MySQL", "high", "Database port exposed. Should not be accessible on network."),
                3389: ("RDP", "high", "RDP is a high-value target for brute-force and exploitation."),
                5900: ("VNC", "high", "VNC often uses weak authentication. Should be tunneled via SSH."),
            }

            for port in open_ports:
                if port in risky_ports:
                    svc_name, severity, remediation = risky_ports[port]
                    findings.append({
                        "title": f"Risky service detected: {svc_name} on port {port}",
                        "severity": severity,
                        "category": "exposure",
                        "description": f"{svc_name} service is listening on {target}:{port}. This service poses security concerns.",
                        "evidence": f"TCP connect to {target}:{port} succeeded",
                        "remediation": remediation,
                    })
        else:
            findings.append({
                "title": f"No open ports found on {target}",
                "severity": "info",
                "category": "info",
                "description": f"None of the {len(check_ports)} checked ports are open on {target}.",
                "evidence": f"Checked ports: {sorted(check_ports)}",
                "remediation": "No action required.",
            })

        logger.info("Port verification complete", target=target, open_count=len(open_ports))
        return findings

    async def _check_port(self, target: str, port: int, semaphore: asyncio.Semaphore) -> bool:
        """Check if a single TCP port is open with timeout."""
        async with semaphore:
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port), timeout=3
                )
                writer.close()
                await writer.wait_closed()
                return True
            except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
                return False

import asyncio
import ipaddress
import re
import ssl
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

DEFAULT_ADMIN_PORTS = [80, 443, 8080, 8443, 9090]

# Common login form indicators
LOGIN_FORM_PATTERNS = [
    r'<form[^>]*>.*?(?:password|passwd|login|signin)',
    r'type=["\']password["\']',
    r'name=["\'](?:password|passwd|pass|pwd)["\']',
    r'id=["\'](?:login|loginForm|signin|auth)',
]

# Default credential indicators in banners/responses
DEFAULT_CRED_INDICATORS = [
    "default password",
    "admin/admin",
    "admin/password",
    "root/root",
    "default credentials",
    "factory default",
    "initial setup",
    "first time setup",
    "change your password",
    "default login",
]


def _is_in_scope(target: str) -> bool:
    """Validate that target IP is within RFC 1918 private ranges."""
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class AdminExposureAction:
    """Check for exposed administrative interfaces on common ports.

    Probes default admin ports for web management interfaces, detects
    login pages by analyzing form elements, and checks for default
    credential indicators in response content.
    """

    action_id = "admin_exposure"
    name = "Admin Interface Exposure Check"
    description = "Detect exposed admin interfaces, login pages, and default credential indicators on common ports."
    risk_level = "medium"

    async def execute(self, target: str, ports: list[int] | None = None) -> list[dict]:
        """Execute admin exposure check.

        Args:
            target: IP address to check (must be RFC 1918).
            ports: Optional list of ports to check. Defaults to [80, 443, 8080, 8443, 9090].

        Returns:
            List of finding dicts for exposed admin interfaces.
        """
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges. Action aborted.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8) are permitted.",
            }]

        check_ports = ports if ports is not None else DEFAULT_ADMIN_PORTS
        logger.info("Starting admin exposure check", target=target, ports=check_ports)
        findings = []

        tasks = [self._check_port(target, port) for port in check_ports]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for port, result in zip(check_ports, results):
            if isinstance(result, Exception):
                logger.debug("Admin check exception", target=target, port=port, error=str(result))
                continue
            findings.extend(result)

        if not findings:
            findings.append({
                "title": f"No exposed admin interfaces on {target}",
                "severity": "info",
                "category": "info",
                "description": f"No administrative interfaces detected on ports {check_ports}.",
                "evidence": f"Checked ports: {check_ports}",
                "remediation": "No action required.",
            })

        logger.info("Admin exposure check complete", target=target, finding_count=len(findings))
        return findings

    async def _check_port(self, target: str, port: int) -> list[dict]:
        """Check a single port for admin interface exposure."""
        findings = []
        use_tls = port in (443, 8443)

        # Try both TLS and non-TLS for ambiguous ports
        protocols_to_try = []
        if use_tls:
            protocols_to_try.append(True)
        elif port in (80, 8080, 9090):
            protocols_to_try.append(False)
        else:
            # Try TLS first, fall back to plain
            protocols_to_try.append(True)
            protocols_to_try.append(False)

        for tls in protocols_to_try:
            try:
                status_code, headers, body = await self._fetch_page(target, port, tls, "/")
                if status_code is None:
                    continue

                scheme = "https" if tls else "http"

                # Service is responding
                server_header = headers.get("server", "")
                title = self._extract_html_title(body)

                findings.append({
                    "title": f"Web service on {scheme}://{target}:{port}",
                    "severity": "info",
                    "category": "exposure",
                    "description": (
                        f"Web service detected. "
                        f"Title: '{title or 'N/A'}', "
                        f"Server: '{server_header or 'N/A'}', "
                        f"Status: {status_code}"
                    ),
                    "evidence": f"{scheme}://{target}:{port}/ -> HTTP {status_code}",
                    "remediation": "Ensure this service requires authentication and is not unnecessarily exposed.",
                })

                # Check for login form
                has_login = self._detect_login_form(body)
                if has_login:
                    findings.append({
                        "title": f"Login page detected on {scheme}://{target}:{port}",
                        "severity": "medium",
                        "category": "exposure",
                        "description": f"A login form was detected on {scheme}://{target}:{port}. "
                                       f"This may be an admin or management interface.",
                        "evidence": f"Login form detected. Page title: '{title or 'N/A'}'",
                        "remediation": "Restrict access to admin interfaces via IP allowlist or VPN. Enforce MFA.",
                    })

                # Check for default credential indicators
                cred_indicators = self._check_default_cred_indicators(body)
                if cred_indicators:
                    findings.append({
                        "title": f"Default credential indicator on {scheme}://{target}:{port}",
                        "severity": "high",
                        "category": "vuln",
                        "description": (
                            f"Response content suggests default credentials may be in use. "
                            f"Indicators found: {', '.join(cred_indicators)}"
                        ),
                        "evidence": f"Matched indicators: {cred_indicators}",
                        "remediation": "Change default credentials immediately. Enforce strong password policy.",
                    })

                # Check for known admin interface fingerprints in banner
                banner_findings = self._analyze_server_banner(server_header, target, port, scheme)
                findings.extend(banner_findings)

                # If TLS succeeded, no need to try plain
                break

            except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
                continue

        return findings

    async def _fetch_page(self, target: str, port: int, use_tls: bool, path: str) -> tuple[int | None, dict, str]:
        """Fetch a page and return status code, headers dict, and body."""
        try:
            if use_tls:
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port, ssl=ctx), timeout=8
                )
            else:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port), timeout=8
                )

            request = (
                f"GET {path} HTTP/1.1\r\n"
                f"Host: {target}\r\n"
                f"Connection: close\r\n"
                f"User-Agent: RiskPlatform-Pentest/1.0\r\n"
                f"\r\n"
            )
            writer.write(request.encode())
            await writer.drain()

            data = await asyncio.wait_for(reader.read(16384), timeout=8)
            response = data.decode("utf-8", errors="replace")
            writer.close()
            await writer.wait_closed()

            # Parse response
            lines = response.split("\r\n")
            status_code = None
            headers = {}

            if lines:
                parts = lines[0].split(" ", 2)
                if len(parts) >= 2:
                    try:
                        status_code = int(parts[1])
                    except ValueError:
                        pass

            body_start = False
            body_lines = []
            for line in lines[1:]:
                if body_start:
                    body_lines.append(line)
                elif line == "":
                    body_start = True
                else:
                    if ":" in line:
                        key, _, value = line.partition(":")
                        headers[key.strip().lower()] = value.strip()

            body = "\n".join(body_lines)
            return status_code, headers, body

        except (asyncio.TimeoutError, ConnectionRefusedError, OSError, ssl.SSLError):
            return None, {}, ""

    def _detect_login_form(self, body: str) -> bool:
        """Detect login form elements in HTML body."""
        if not body:
            return False
        body_lower = body.lower()
        for pattern in LOGIN_FORM_PATTERNS:
            if re.search(pattern, body_lower, re.IGNORECASE | re.DOTALL):
                return True
        return False

    def _check_default_cred_indicators(self, body: str) -> list[str]:
        """Check for default credential indicators in response body."""
        if not body:
            return []
        body_lower = body.lower()
        found = []
        for indicator in DEFAULT_CRED_INDICATORS:
            if indicator in body_lower:
                found.append(indicator)
        return found

    @staticmethod
    def _extract_html_title(body: str) -> str | None:
        """Extract the HTML <title> tag content."""
        if not body:
            return None
        match = re.search(r"<title[^>]*>(.*?)</title>", body, re.IGNORECASE | re.DOTALL)
        return match.group(1).strip() if match else None

    def _analyze_server_banner(self, server_header: str, target: str, port: int, scheme: str) -> list[dict]:
        """Analyze server banner for known admin interface fingerprints."""
        findings = []
        if not server_header:
            return findings

        server_lower = server_header.lower()

        known_admin_servers = {
            "webmin": ("Webmin", "high", "Webmin is a system administration tool. Ensure it requires strong authentication."),
            "cockpit": ("Cockpit", "medium", "Cockpit is a server management interface. Restrict access via firewall rules."),
            "proxmox": ("Proxmox VE", "high", "Proxmox VE management interface exposed. Restrict to management VLAN."),
            "mikrotik": ("MikroTik RouterOS", "high", "MikroTik management interface exposed. Restrict to trusted IPs only."),
            "ubnt": ("Ubiquiti", "medium", "Ubiquiti management interface detected. Restrict access and update firmware."),
            "unifi": ("UniFi Controller", "medium", "UniFi Controller detected. Restrict access to management network."),
            "synology": ("Synology DSM", "medium", "Synology NAS management interface. Restrict access and enable 2FA."),
            "qnap": ("QNAP QTS", "medium", "QNAP NAS management interface. Restrict access and keep firmware updated."),
            "pfsense": ("pfSense", "high", "pfSense firewall management interface. Restrict access to trusted IPs."),
            "opnsense": ("OPNsense", "high", "OPNsense firewall management interface. Restrict access to trusted IPs."),
        }

        for keyword, (name, severity, remediation) in known_admin_servers.items():
            if keyword in server_lower:
                findings.append({
                    "title": f"Known admin interface detected: {name} on {scheme}://{target}:{port}",
                    "severity": severity,
                    "category": "exposure",
                    "description": f"{name} management interface identified via server banner: '{server_header}'.",
                    "evidence": f"Server header: {server_header}",
                    "remediation": remediation,
                })
                break

        return findings

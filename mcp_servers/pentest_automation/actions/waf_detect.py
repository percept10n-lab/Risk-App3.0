"""WAF Detection action â€” NeuroSploit-derived.

Sends 5 probe requests concurrently (normal, SQLi, XSS, path traversal,
malicious UA), matches responses against 16 WAF signature sets, and
performs behavioral analysis to detect unnamed WAFs via status code
divergence.
"""

import asyncio
import structlog

from mcp_servers.pentest_automation.actions.neurosploit_utils import (
    is_in_scope,
    out_of_scope_finding,
    confidence_score,
    async_http_request,
    WAF_SIGNATURES,
    WAF_BYPASS_TECHNIQUES,
)

logger = structlog.get_logger()

# Probe payloads: (name, path, extra_headers)
PROBES = [
    ("baseline", "/", {}),
    ("sqli", "/?id=1' OR '1'='1", {}),
    ("xss", "/?q=<script>alert(1)</script>", {}),
    ("path_traversal", "/../../etc/passwd", {}),
    ("malicious_ua", "/", {"User-Agent": "sqlmap/1.5 (http://sqlmap.org)"}),
]


class WAFDetectAction:
    """Detect Web Application Firewalls via signature matching and behavioral analysis."""

    action_id = "waf_detect"
    name = "WAF Detection"
    description = "Detect web application firewalls using probe requests, signature matching, and behavioral analysis."
    risk_level = "low"

    async def execute(self, target: str, port: int = 80, use_tls: bool = False, on_progress=None) -> list[dict]:
        if not is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [out_of_scope_finding(target)]

        async def emit(msg: str):
            if on_progress:
                await on_progress(msg)

        logger.info("Starting WAF detection", target=target, port=port, tls=use_tls)

        # Send all probes concurrently
        await emit("Sending baseline probe...")
        await emit("Sending SQLi probe...")
        await emit("Sending XSS probe...")
        await emit("Sending path traversal probe...")
        await emit("Sending malicious UA probe...")
        tasks = [
            self._send_probe(target, port, use_tls, name, path, extra_headers)
            for name, path, extra_headers in PROBES
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        probe_results: dict[str, dict] = {}
        for (name, _, _), result in zip(PROBES, results):
            if isinstance(result, Exception):
                logger.debug("Probe failed", probe=name, error=str(result))
                continue
            probe_results[name] = result

        if not probe_results:
            return [{
                "title": f"WAF detection: No HTTP response from {target}:{port}",
                "severity": "info",
                "category": "info",
                "description": f"Could not connect to {target}:{port} for WAF detection.",
                "evidence": "All probe requests failed.",
                "remediation": "Verify the service is running and accessible.",
            }]

        findings = []

        # Phase 1: Signature-based WAF detection
        detected_wafs = self._match_signatures(probe_results)
        for waf_name in detected_wafs:
            await emit(f"Checking {waf_name} signatures...")
        for waf_name, signals in detected_wafs.items():
            conf = confidence_score(
                positive=len(signals),
                total=5,
                has_evidence=True,
                fp_risk=0.1,
            )
            bypass_categories = list(WAF_BYPASS_TECHNIQUES.keys())
            findings.append({
                "title": f"WAF detected: {waf_name}",
                "severity": "info",
                "category": "recon",
                "description": (
                    f"Web Application Firewall identified: {waf_name}. "
                    f"Confidence: {conf}%. Matched {len(signals)} signal(s). "
                    f"Bypass technique categories to explore: {', '.join(bypass_categories)}."
                ),
                "evidence": f"Matched signals: {signals}",
                "remediation": "WAF presence is informational. Ensure WAF rules are regularly updated.",
                "confidence": conf,
                "waf_name": waf_name,
                "bypass_categories": bypass_categories,
            })

        # Phase 2: Behavioral analysis (unnamed WAF detection)
        await emit("Running behavioral analysis...")
        behavioral = self._behavioral_analysis(probe_results)
        if behavioral and not detected_wafs:
            findings.append({
                "title": f"Unnamed WAF/filtering detected on {target}:{port}",
                "severity": "info",
                "category": "recon",
                "description": (
                    f"Behavioral analysis indicates request filtering. "
                    f"Baseline returned HTTP {behavioral['baseline_status']}, "
                    f"but attack probes returned {behavioral['blocked_statuses']}. "
                    f"This suggests an unnamed WAF or filtering device."
                ),
                "evidence": f"Status code divergence: baseline={behavioral['baseline_status']}, "
                            f"probes={behavioral['blocked_statuses']}",
                "remediation": "Investigate what device is filtering requests. Ensure rules are current.",
                "confidence": behavioral["confidence"],
            })

        if not findings:
            findings.append({
                "title": f"No WAF detected on {target}:{port}",
                "severity": "info",
                "category": "recon",
                "description": "No Web Application Firewall was detected via signature or behavioral analysis.",
                "evidence": f"Probes sent: {list(probe_results.keys())}",
                "remediation": "Consider deploying a WAF to protect web applications.",
            })

        logger.info("WAF detection complete", target=target, findings=len(findings))
        return findings

    async def _send_probe(
        self,
        target: str,
        port: int,
        use_tls: bool,
        name: str,
        path: str,
        extra_headers: dict[str, str],
    ) -> dict:
        """Send a single probe and return parsed response metadata."""
        status, headers, body = await async_http_request(
            target, port, path=path, use_tls=use_tls, headers=extra_headers or None,
        )
        return {
            "name": name,
            "status_code": status,
            "headers": headers,
            "body_lower": body.lower()[:4096] if body else "",
            "cookies": headers.get("set-cookie", "").lower(),
        }

    def _match_signatures(self, probe_results: dict[str, dict]) -> dict[str, list[str]]:
        """Match probe responses against WAF signature database."""
        detected: dict[str, list[str]] = {}

        for waf_name, sigs in WAF_SIGNATURES.items():
            signals: list[str] = []

            for probe_data in probe_results.values():
                # Header matching
                for sig_header, sig_patterns in sigs.get("headers", {}).items():
                    header_val = probe_data["headers"].get(sig_header, "")
                    if header_val:
                        if not sig_patterns or sig_patterns == [""]:
                            signals.append(f"header:{sig_header} present")
                        else:
                            for pat in sig_patterns:
                                if pat and pat in header_val.lower():
                                    signals.append(f"header:{sig_header}={pat}")

                # Body matching
                for body_pattern in sigs.get("body", []):
                    if body_pattern and body_pattern in probe_data["body_lower"]:
                        signals.append(f"body:{body_pattern[:40]}")

                # Cookie matching
                for cookie_pattern in sigs.get("cookies", []):
                    if cookie_pattern and cookie_pattern in probe_data["cookies"]:
                        signals.append(f"cookie:{cookie_pattern}")

            # Deduplicate signals
            unique_signals = list(dict.fromkeys(signals))
            if unique_signals:
                detected[waf_name] = unique_signals

        return detected

    def _behavioral_analysis(self, probe_results: dict[str, dict]) -> dict | None:
        """Detect unnamed WAFs via status code divergence."""
        baseline = probe_results.get("baseline")
        if not baseline or baseline["status_code"] is None:
            return None

        baseline_status = baseline["status_code"]
        if baseline_status >= 400:
            return None  # Can't compare if baseline itself is error

        blocked_statuses = {}
        for name, data in probe_results.items():
            if name == "baseline":
                continue
            if data["status_code"] is not None and data["status_code"] in (403, 406, 429, 503):
                blocked_statuses[name] = data["status_code"]

        if len(blocked_statuses) >= 2:
            conf = confidence_score(
                positive=len(blocked_statuses),
                total=len(probe_results) - 1,
                has_evidence=True,
                fp_risk=0.3,
            )
            return {
                "baseline_status": baseline_status,
                "blocked_statuses": blocked_statuses,
                "confidence": conf,
            }

        return None

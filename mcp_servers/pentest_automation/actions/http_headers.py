import asyncio
import ipaddress
import ssl
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

SECURITY_HEADERS = {
    "strict-transport-security": {
        "name": "Strict-Transport-Security (HSTS)",
        "severity": "medium",
        "description": "HSTS forces browsers to use HTTPS, preventing protocol downgrade attacks.",
        "remediation": "Add header: Strict-Transport-Security: max-age=31536000; includeSubDomains",
    },
    "x-content-type-options": {
        "name": "X-Content-Type-Options",
        "severity": "low",
        "description": "Prevents MIME-type sniffing which can lead to XSS attacks.",
        "remediation": "Add header: X-Content-Type-Options: nosniff",
    },
    "x-frame-options": {
        "name": "X-Frame-Options",
        "severity": "medium",
        "description": "Prevents clickjacking by controlling iframe embedding.",
        "remediation": "Add header: X-Frame-Options: DENY or SAMEORIGIN",
    },
    "content-security-policy": {
        "name": "Content-Security-Policy (CSP)",
        "severity": "medium",
        "description": "CSP mitigates XSS and data injection attacks by controlling allowed resource sources.",
        "remediation": "Add a Content-Security-Policy header with appropriate directives.",
    },
    "x-xss-protection": {
        "name": "X-XSS-Protection",
        "severity": "low",
        "description": "Legacy XSS filter. While deprecated, its absence may indicate lack of security awareness.",
        "remediation": "Add header: X-XSS-Protection: 0 (or rely on CSP instead)",
    },
    "referrer-policy": {
        "name": "Referrer-Policy",
        "severity": "low",
        "description": "Controls how much referrer information is sent with requests.",
        "remediation": "Add header: Referrer-Policy: strict-origin-when-cross-origin",
    },
    "permissions-policy": {
        "name": "Permissions-Policy",
        "severity": "low",
        "description": "Controls browser features available to the page (camera, microphone, geolocation).",
        "remediation": "Add a Permissions-Policy header restricting unnecessary browser features.",
    },
}

ADMIN_PATHS = [
    "/admin",
    "/login",
    "/manager",
    "/dashboard",
    "/phpmyadmin",
    "/wp-admin",
]


def _is_in_scope(target: str) -> bool:
    """Validate that target IP is within RFC 1918 private ranges."""
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class HTTPHeadersAction:
    """Check HTTP security headers and probe for common admin paths.

    Verifies the presence of recommended security headers and checks
    well-known admin paths for exposed management interfaces.
    """

    action_id = "http_headers"
    name = "HTTP Security Headers & Admin Path Check"
    description = "Verify HTTP security headers and check for exposed admin paths on web services."
    risk_level = "low"

    async def execute(self, target: str, port: int = 80, use_tls: bool = False, on_progress=None) -> list[dict]:
        """Execute HTTP headers and admin path checks.

        Args:
            target: IP address to check (must be RFC 1918).
            port: HTTP port number.
            use_tls: Whether to use HTTPS.
            on_progress: Optional async callback for terminal-style output.

        Returns:
            List of finding dicts for missing headers and exposed admin paths.
        """
        async def emit(msg: str):
            if on_progress:
                await on_progress(msg)

        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action="http_headers")
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges. Action aborted.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8) are permitted.",
            }]

        scheme = "https" if use_tls else "http"
        logger.info("Starting HTTP headers check", target=target, port=port, tls=use_tls)
        await emit(f"$ curl -sI {scheme}://{target}:{port}/")
        findings = []

        # Phase 1: Check security headers
        await emit("Checking security headers...")
        header_findings = await self._check_security_headers(target, port, use_tls)
        for f in header_findings:
            status = "FAIL" if f.get("severity") not in ("info",) else "INFO"
            await emit(f"  {status}: {f['title']}")
        findings.extend(header_findings)

        # Phase 2: Check admin paths
        await emit(f"Probing {len(ADMIN_PATHS)} admin paths...")
        admin_findings = await self._check_admin_paths(target, port, use_tls)
        for f in admin_findings:
            await emit(f"  FOUND: {f['title']}")
        findings.extend(admin_findings)

        await emit(f"HTTP headers check complete â€” {len(findings)} findings")
        logger.info("HTTP headers check complete", target=target, finding_count=len(findings))
        return findings

    async def _check_security_headers(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Fetch headers from root path and check for missing security headers."""
        findings = []
        try:
            headers, server_header, status_code = await self._fetch_headers(target, port, use_tls, "/")
        except Exception as e:
            logger.warning("HTTP header fetch failed", target=target, port=port, error=str(e))
            return [{
                "title": f"HTTP{'S' if use_tls else ''} service on port {port} not responding",
                "severity": "info",
                "category": "info",
                "description": f"Could not connect to HTTP{'S' if use_tls else ''} service: {str(e)}",
                "evidence": str(e),
                "remediation": "Verify the service is running and accessible.",
            }]

        # Check each security header
        for header_key, info in SECURITY_HEADERS.items():
            # Only check HSTS for TLS services
            if header_key == "strict-transport-security" and not use_tls:
                continue
            if header_key not in headers:
                findings.append({
                    "title": f"Missing {info['name']} header",
                    "severity": info["severity"],
                    "category": "misconfig",
                    "description": info["description"],
                    "evidence": f"Header '{header_key}' not found in HTTP response from {target}:{port}",
                    "remediation": info["remediation"],
                })

        # Server header information disclosure
        if server_header:
            findings.append({
                "title": "Server header reveals software version",
                "severity": "low",
                "category": "info",
                "description": f"The Server header discloses: {server_header}. This helps attackers identify specific vulnerabilities.",
                "evidence": f"Server: {server_header}",
                "remediation": "Configure the web server to suppress or generalize the Server header.",
            })

        # Cleartext HTTP warning
        if not use_tls and port in (80, 8080, 8000):
            findings.append({
                "title": f"HTTP service without TLS on port {port}",
                "severity": "medium",
                "category": "misconfig",
                "description": "Service uses unencrypted HTTP. Credentials and data transmitted in cleartext.",
                "evidence": f"HTTP (no TLS) service detected on {target}:{port}",
                "remediation": "Enable HTTPS/TLS and redirect HTTP to HTTPS.",
            })

        return findings

    async def _check_admin_paths(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Check common admin paths for exposed management interfaces.

        First probes a random non-existent path to detect catch-all handlers
        (e.g. SPAs, embedded web UIs) that return 200 for any path.
        """
        findings = []

        # Baseline: probe a random path to detect catch-all handlers
        baseline_status, baseline_body = await self._probe_path(
            target, port, use_tls, "/riskplatform-nonexistent-path-check-8f3a"
        )
        has_catchall = baseline_status is not None and baseline_status < 400

        if has_catchall:
            logger.info(
                "Catch-all handler detected, skipping admin path checks",
                target=target, port=port, baseline_status=baseline_status,
            )
            return findings

        tasks = [self._probe_path(target, port, use_tls, path) for path in ADMIN_PATHS]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for path, result in zip(ADMIN_PATHS, results):
            if isinstance(result, Exception):
                logger.debug("Admin path probe failed", path=path, error=str(result))
                continue
            status_code, body_snippet = result
            if status_code is not None and status_code < 400:
                severity = "high" if status_code == 200 else "medium"
                findings.append({
                    "title": f"Exposed admin path: {path} (HTTP {status_code})",
                    "severity": severity,
                    "category": "exposure",
                    "description": f"Admin path '{path}' returned HTTP {status_code} on {target}:{port}. "
                                   f"This may expose a management interface.",
                    "evidence": f"GET {path} -> HTTP {status_code}. Body preview: {body_snippet[:200]}",
                    "remediation": f"Restrict access to {path} via IP allowlist, authentication, or remove if unnecessary.",
                })

        return findings

    async def _fetch_headers(self, target: str, port: int, use_tls: bool, path: str) -> tuple[dict, str | None, int]:
        """Fetch HTTP headers from a given path."""
        if use_tls:
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port, ssl=ctx), timeout=10
            )
        else:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port), timeout=10
            )

        request = (
            f"HEAD {path} HTTP/1.1\r\n"
            f"Host: {target}\r\n"
            f"Connection: close\r\n"
            f"User-Agent: RiskPlatform-Pentest/1.0\r\n"
            f"\r\n"
        )
        writer.write(request.encode())
        await writer.drain()

        data = await asyncio.wait_for(reader.read(8192), timeout=10)
        response = data.decode("utf-8", errors="replace")
        writer.close()
        await writer.wait_closed()

        headers = {}
        server_header = None
        status_code = 0
        lines = response.split("\r\n")

        if lines:
            parts = lines[0].split(" ", 2)
            if len(parts) >= 2:
                try:
                    status_code = int(parts[1])
                except ValueError:
                    pass

        for line in lines[1:]:
            if ":" in line:
                key, _, value = line.partition(":")
                key_lower = key.strip().lower()
                headers[key_lower] = value.strip()
                if key_lower == "server":
                    server_header = value.strip()

        return headers, server_header, status_code

    async def _probe_path(self, target: str, port: int, use_tls: bool, path: str) -> tuple[int | None, str]:
        """Send a GET request to a path and return status code and body snippet."""
        try:
            if use_tls:
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port, ssl=ctx), timeout=8
                )
            else:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port), timeout=8
                )

            request = (
                f"GET {path} HTTP/1.1\r\n"
                f"Host: {target}\r\n"
                f"Connection: close\r\n"
                f"User-Agent: RiskPlatform-Pentest/1.0\r\n"
                f"\r\n"
            )
            writer.write(request.encode())
            await writer.drain()

            data = await asyncio.wait_for(reader.read(4096), timeout=8)
            response = data.decode("utf-8", errors="replace")
            writer.close()
            await writer.wait_closed()

            lines = response.split("\r\n")
            status_code = None
            if lines:
                parts = lines[0].split(" ", 2)
                if len(parts) >= 2:
                    try:
                        status_code = int(parts[1])
                    except ValueError:
                        pass

            # Extract body (after empty line)
            body = ""
            in_body = False
            for line in lines:
                if in_body:
                    body += line + "\n"
                elif line == "":
                    in_body = True

            return status_code, body.strip()
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError) as e:
            logger.debug("Admin path probe connection failed", path=path, error=str(e))
            return None, ""

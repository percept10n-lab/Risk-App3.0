"""Default Credentials Check action.

Inspired by NeuroSploit's auth_manager and access_control_learner â€”
tests common services for default or well-known credentials that
are often left unchanged on home network devices.
"""

import asyncio
import ipaddress
import ssl
import base64
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

# Default credential database for common home network devices
# Only includes widely-known manufacturer defaults (public knowledge)
DEFAULT_CREDS_HTTP = [
    {"user": "admin", "pass": "admin"},
    {"user": "admin", "pass": "password"},
    {"user": "admin", "pass": "1234"},
    {"user": "admin", "pass": ""},
    {"user": "root", "pass": "root"},
    {"user": "root", "pass": "admin"},
    {"user": "root", "pass": ""},
    {"user": "user", "pass": "user"},
    {"user": "pi", "pass": "raspberry"},
]

# Services to test with their ports and authentication methods
SERVICE_CHECKS = {
    "http_basic_auth": {
        "ports": [80, 8080, 8443, 443, 9090],
        "paths": ["/", "/admin", "/login", "/api", "/management"],
    },
    "ftp": {
        "port": 21,
        "anonymous": True,
    },
}

# Common router/device admin paths that require HTTP Basic Auth
ADMIN_PATHS_AUTH = [
    "/",
    "/admin",
    "/cgi-bin/luci",
    "/webfig/",
    "/manage",
    "/config",
    "/status",
]


def _is_in_scope(target: str) -> bool:
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class DefaultCredsAction:
    """Test services for default credentials.

    Checks HTTP services for Basic Auth with common default credentials,
    and FTP for anonymous access. Only tests widely-known manufacturer
    defaults that are public knowledge.
    Based on NeuroSploit's auth_manager module.
    """

    action_id = "default_creds"
    name = "Default Credentials Check"
    description = "Test for default/factory credentials on web interfaces and FTP (public manufacturer defaults only)."
    risk_level = "high"
    category = "neurosploit"

    async def execute(self, target: str, ports: list[int] | None = None) -> list[dict]:
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs are permitted.",
            }]

        logger.info("Starting default credentials check", target=target)
        findings = []
        check_ports = ports or SERVICE_CHECKS["http_basic_auth"]["ports"]

        # Phase 1: HTTP Basic Auth checks
        semaphore = asyncio.Semaphore(3)  # Low concurrency to avoid lockouts
        tasks = []
        for port in check_ports:
            for use_tls in [False, True] if port in (443, 8443) else [False]:
                tasks.append(
                    self._check_http_auth(target, port, use_tls, semaphore)
                )

        results = await asyncio.gather(*tasks, return_exceptions=True)
        for result in results:
            if isinstance(result, Exception):
                continue
            findings.extend(result)

        # Phase 2: FTP anonymous access check
        ftp_findings = await self._check_ftp_anonymous(target)
        findings.extend(ftp_findings)

        if not findings:
            findings.append({
                "title": f"No default credentials found on {target}",
                "severity": "info",
                "category": "info",
                "description": "No services with default credentials were detected.",
                "evidence": f"Tested {len(check_ports)} HTTP ports and FTP (21).",
                "remediation": "Continue to use strong, unique passwords.",
            })

        logger.info("Default credentials check complete", target=target, finding_count=len(findings))
        return findings

    async def _check_http_auth(
        self, target: str, port: int, use_tls: bool, semaphore: asyncio.Semaphore
    ) -> list[dict]:
        """Test HTTP service for Basic Auth with default credentials."""
        findings = []

        for path in ADMIN_PATHS_AUTH:
            # First, check if the path requires authentication (returns 401)
            async with semaphore:
                response = await self._http_request(target, port, use_tls, path)

            if response is None:
                break  # Port not reachable
            status, headers, body = response

            if status != 401:
                continue  # No auth required on this path

            # Check if WWW-Authenticate indicates Basic Auth
            www_auth = headers.get("www-authenticate", "")
            if "basic" not in www_auth.lower():
                continue

            realm = ""
            if "realm=" in www_auth.lower():
                realm = www_auth.split("realm=", 1)[1].strip('" ')

            # Test default credentials
            for cred in DEFAULT_CREDS_HTTP:
                async with semaphore:
                    auth_response = await self._http_request_with_auth(
                        target, port, use_tls, path,
                        cred["user"], cred["pass"]
                    )

                if auth_response is None:
                    continue

                auth_status, _, _ = auth_response

                if auth_status in (200, 301, 302, 303, 307, 308):
                    findings.append({
                        "title": f"Default credentials accepted on {target}:{port}{path}",
                        "severity": "critical",
                        "category": "vuln",
                        "cwe_id": "CWE-798",
                        "description": (
                            f"HTTP Basic Auth on {target}:{port}{path} accepts default credentials. "
                            f"{'Realm: ' + realm if realm else ''} "
                            f"An attacker with network access can gain administrative control."
                        ),
                        "evidence": (
                            f"Port: {port}\n"
                            f"Path: {path}\n"
                            f"Auth: HTTP Basic\n"
                            f"Realm: {realm or 'N/A'}\n"
                            f"User: {cred['user']}\n"
                            f"Password: {'(empty)' if not cred['pass'] else '***'}\n"
                            f"Result: HTTP {auth_status}"
                        ),
                        "remediation": (
                            "Immediately change the default password. Use a strong, unique password. "
                            "Consider restricting admin interface access to specific IPs."
                        ),
                    })
                    break  # Don't test more creds for this path

                # Small delay between attempts to avoid lockout
                await asyncio.sleep(0.5)

        return findings

    async def _check_ftp_anonymous(self, target: str) -> list[dict]:
        """Check if FTP allows anonymous access."""
        findings = []
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, 21), timeout=5
            )

            # Read banner
            banner = await asyncio.wait_for(reader.readline(), timeout=5)
            banner_text = banner.decode("utf-8", errors="replace").strip()

            # Try anonymous login
            writer.write(b"USER anonymous\r\n")
            await writer.drain()
            user_resp = await asyncio.wait_for(reader.readline(), timeout=5)

            writer.write(b"PASS anonymous@\r\n")
            await writer.drain()
            pass_resp = await asyncio.wait_for(reader.readline(), timeout=5)
            pass_text = pass_resp.decode("utf-8", errors="replace").strip()

            writer.write(b"QUIT\r\n")
            await writer.drain()
            writer.close()
            await writer.wait_closed()

            if pass_text.startswith("230"):
                findings.append({
                    "title": f"FTP anonymous access allowed on {target}:21",
                    "severity": "high",
                    "category": "vuln",
                    "cwe_id": "CWE-284",
                    "description": (
                        "FTP service allows anonymous login. Anyone on the network "
                        "can access files without authentication."
                    ),
                    "evidence": (
                        f"FTP Banner: {banner_text}\n"
                        f"Anonymous login: Accepted (230)\n"
                        f"Response: {pass_text}"
                    ),
                    "remediation": "Disable anonymous FTP access. Require authentication for all FTP connections.",
                })

        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            pass  # FTP not available

        return findings

    async def _http_request(
        self, target: str, port: int, use_tls: bool, path: str
    ) -> tuple[int, dict, str] | None:
        try:
            if use_tls:
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port, ssl=ctx), timeout=5
                )
            else:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port), timeout=5
                )

            request = (
                f"GET {path} HTTP/1.1\r\n"
                f"Host: {target}\r\n"
                f"Connection: close\r\n"
                f"User-Agent: Mozilla/5.0 (compatible; SecurityAudit/1.0)\r\n"
                f"\r\n"
            )
            writer.write(request.encode())
            await writer.drain()

            data = await asyncio.wait_for(reader.read(4096), timeout=5)
            response = data.decode("utf-8", errors="replace")
            writer.close()
            await writer.wait_closed()

            return self._parse_response(response)
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return None

    async def _http_request_with_auth(
        self, target: str, port: int, use_tls: bool, path: str,
        username: str, password: str
    ) -> tuple[int, dict, str] | None:
        try:
            if use_tls:
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port, ssl=ctx), timeout=5
                )
            else:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port), timeout=5
                )

            auth_str = base64.b64encode(f"{username}:{password}".encode()).decode()
            request = (
                f"GET {path} HTTP/1.1\r\n"
                f"Host: {target}\r\n"
                f"Authorization: Basic {auth_str}\r\n"
                f"Connection: close\r\n"
                f"User-Agent: Mozilla/5.0 (compatible; SecurityAudit/1.0)\r\n"
                f"\r\n"
            )
            writer.write(request.encode())
            await writer.drain()

            data = await asyncio.wait_for(reader.read(4096), timeout=5)
            response = data.decode("utf-8", errors="replace")
            writer.close()
            await writer.wait_closed()

            return self._parse_response(response)
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return None

    def _parse_response(self, response: str) -> tuple[int, dict, str]:
        status_code = 0
        headers = {}
        lines = response.split("\r\n")
        if lines:
            parts = lines[0].split(" ", 2)
            if len(parts) >= 2:
                try:
                    status_code = int(parts[1])
                except ValueError:
                    pass

        body_start = False
        body = ""
        for line in lines[1:]:
            if body_start:
                body += line + "\n"
            elif line == "":
                body_start = True
            elif ":" in line:
                key, _, value = line.partition(":")
                headers[key.strip().lower()] = value.strip()

        return status_code, headers, body.strip()

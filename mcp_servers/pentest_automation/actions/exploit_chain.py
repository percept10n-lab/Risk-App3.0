"""Exploit Chain Analyzer action — NeuroSploit-derived.

Analyzes existing pentest findings from the database to identify
multi-step attack paths. No network traffic — purely analytical.
Implements 10 chain rules inspired by NeuroSploit's attack graph concept.
"""

import structlog

from mcp_servers.pentest_automation.actions.neurosploit_utils import (
    is_in_scope,
    out_of_scope_finding,
    confidence_score,
)

logger = structlog.get_logger()


# ---------------------------------------------------------------------------
# Chain rule definitions
# Each rule: {name, description, required_indicators, severity, cwe_id, remediation}
# required_indicators: list of lambdas that check if a finding matches
# ---------------------------------------------------------------------------

def _title_contains(text: str):
    """Return a matcher that checks if finding title contains text (case-insensitive)."""
    text_lower = text.lower()
    return lambda f: text_lower in f.get("title", "").lower()


def _category_is(cat: str):
    """Return a matcher that checks finding category."""
    return lambda f: f.get("category", "").lower() == cat.lower()


def _source_is(source: str):
    """Return a matcher that checks source_tool."""
    return lambda f: source.lower() in f.get("source_tool", "").lower()


def _severity_gte(level: str):
    """Return a matcher that checks severity >= level."""
    order = {"info": 0, "low": 1, "medium": 2, "high": 3, "critical": 4}
    threshold = order.get(level.lower(), 0)
    return lambda f: order.get(f.get("severity", "info").lower(), 0) >= threshold


def _any_keyword(*keywords):
    """Return a matcher that checks if any keyword appears in title or description."""
    kw_lower = [k.lower() for k in keywords]
    return lambda f: any(
        k in f.get("title", "").lower() or k in f.get("description", "").lower()
        for k in kw_lower
    )


CHAIN_RULES = [
    {
        "name": "MITM Path: Weak TLS + Exposed Services",
        "description": (
            "Weak TLS configuration combined with exposed network services "
            "creates a man-in-the-middle attack opportunity."
        ),
        "indicators": [
            ("Weak TLS", _any_keyword("tls", "ssl", "certificate", "cipher")),
            ("Exposed service", _any_keyword("open port", "exposed", "service")),
        ],
        "severity": "high",
        "cwe_id": "CWE-300",
        "remediation": "Upgrade TLS to 1.2+ with strong ciphers. Restrict service exposure to necessary ports.",
    },
    {
        "name": "Admin Compromise: Admin Interface + Default Credentials",
        "description": (
            "An exposed admin interface combined with default credential indicators "
            "enables administrative takeover."
        ),
        "indicators": [
            ("Admin interface", _any_keyword("admin", "management interface", "login page")),
            ("Default creds", _any_keyword("default credential", "default password", "admin/admin")),
        ],
        "severity": "critical",
        "cwe_id": "CWE-798",
        "remediation": "Change all default credentials. Restrict admin interfaces to VPN/trusted IPs. Enable MFA.",
    },
    {
        "name": "SSH Lateral Movement: Weak SSH + Open Ports",
        "description": (
            "Weak SSH configuration with multiple open ports enables "
            "lateral movement after initial compromise."
        ),
        "indicators": [
            ("Weak SSH", _any_keyword("ssh", "key exchange", "root login")),
            ("Open ports", _any_keyword("open port", "risky service")),
        ],
        "severity": "high",
        "cwe_id": "CWE-250",
        "remediation": "Harden SSH config (disable root, use keys only). Close unnecessary ports.",
    },
    {
        "name": "Data Exfiltration: Exposed Database Port",
        "description": (
            "An exposed database port (MySQL, PostgreSQL, MSSQL) provides "
            "a direct data exfiltration path."
        ),
        "indicators": [
            ("Database port", _any_keyword("mysql", "3306", "postgresql", "5432", "mssql", "1433", "database")),
            ("Network exposure", _any_keyword("open port", "exposed", "listening")),
        ],
        "severity": "critical",
        "cwe_id": "CWE-284",
        "remediation": "Block database ports from external access. Use firewall rules and bind to localhost.",
    },
    {
        "name": "UPnP NAT Bypass: IGD + Internal Services",
        "description": (
            "UPnP IGD service can be abused to create port forwarding rules, "
            "exposing internal services to the internet."
        ),
        "indicators": [
            ("UPnP/IGD", _any_keyword("upnp", "igd", "ssdp", "port forwarding")),
            ("Internal service", _any_keyword("open port", "service", "listening")),
        ],
        "severity": "high",
        "cwe_id": "CWE-284",
        "remediation": "Disable UPnP on routers. Use explicit port forwarding rules if needed.",
    },
    {
        "name": "SMB Ransomware Pathway",
        "description": (
            "Exposed SMB service (port 445) is a primary vector for "
            "ransomware propagation and lateral movement."
        ),
        "indicators": [
            ("SMB exposed", _any_keyword("smb", "445", "netbios", "139")),
            ("Severity indicator", _severity_gte("medium")),
        ],
        "severity": "critical",
        "cwe_id": "CWE-284",
        "remediation": "Block SMB (445/139) from external networks. Patch aggressively (EternalBlue etc).",
    },
    {
        "name": "RDP Brute Force Path",
        "description": (
            "Exposed RDP service (port 3389) is a high-value target for "
            "brute-force attacks and known exploits (BlueKeep)."
        ),
        "indicators": [
            ("RDP exposed", _any_keyword("rdp", "3389", "remote desktop")),
            ("Severity indicator", _severity_gte("medium")),
        ],
        "severity": "high",
        "cwe_id": "CWE-307",
        "remediation": "Disable RDP or restrict to VPN only. Enable NLA and account lockout policies.",
    },
    {
        "name": "Info Disclosure Chain: Version Leak + Tech Fingerprint",
        "description": (
            "Server version disclosure combined with technology fingerprinting "
            "enables targeted exploit selection."
        ),
        "indicators": [
            ("Version leak", _any_keyword("server header", "version", "software")),
            ("Tech fingerprint", _any_keyword("detected", "framework", "cms", "technology")),
        ],
        "severity": "medium",
        "cwe_id": "CWE-200",
        "remediation": "Suppress version headers. Remove default files and error pages that reveal technology stack.",
    },
    {
        "name": "XSS Session Hijack: XSS + Missing CSP",
        "description": (
            "Cross-site scripting vulnerability combined with missing Content "
            "Security Policy enables session token theft."
        ),
        "indicators": [
            ("XSS", _any_keyword("xss", "cross-site scripting", "reflected", "script")),
            ("Missing CSP", _any_keyword("content-security-policy", "csp", "missing")),
        ],
        "severity": "high",
        "cwe_id": "CWE-79",
        "remediation": "Fix XSS vulnerabilities. Deploy strict CSP. Use HttpOnly and Secure cookie flags.",
    },
    {
        "name": "SQLi Data Breach: SQL Injection + Database Exposure",
        "description": (
            "SQL injection vulnerability combined with database exposure "
            "creates a direct path to data breach."
        ),
        "indicators": [
            ("SQLi", _any_keyword("sql injection", "sqli", "sql error")),
            ("Database", _any_keyword("database", "mysql", "postgresql", "data")),
        ],
        "severity": "critical",
        "cwe_id": "CWE-89",
        "remediation": "Fix SQL injection immediately. Use parameterized queries. Restrict database network access.",
    },
]


class ExploitChainAction:
    """Analyze existing findings to identify multi-step exploit chains."""

    action_id = "exploit_chain"
    name = "Exploit Chain Analyzer"
    description = "Analyze existing pentest findings to identify multi-step attack chains and escalation paths."
    risk_level = "low"

    async def execute(self, target: str, findings: list[dict] | None = None, **kwargs) -> list[dict]:
        if not is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [out_of_scope_finding(target)]

        existing = findings or []
        logger.info("Starting exploit chain analysis", target=target, input_findings=len(existing))

        if not existing:
            return [{
                "title": "Exploit chain analysis: No findings to analyze",
                "severity": "info",
                "category": "info",
                "description": (
                    "No existing findings were provided for chain analysis. "
                    "Run other pentest actions first (port_verify, http_headers, tls_check, etc.) "
                    "to generate findings that can be analyzed for attack chains."
                ),
                "evidence": f"Target: {target}, input findings: 0",
                "remediation": "Execute individual pentest actions before running chain analysis.",
            }]

        chain_findings = []

        for rule in CHAIN_RULES:
            matched_indicators = []
            for indicator_name, matcher in rule["indicators"]:
                matching_findings = [f for f in existing if matcher(f)]
                if matching_findings:
                    matched_indicators.append({
                        "indicator": indicator_name,
                        "matched_count": len(matching_findings),
                        "examples": [f.get("title", "N/A") for f in matching_findings[:3]],
                    })

            # Chain triggers only when ALL indicators are present
            if len(matched_indicators) == len(rule["indicators"]):
                total_matches = sum(m["matched_count"] for m in matched_indicators)
                conf = confidence_score(
                    positive=len(matched_indicators),
                    total=len(rule["indicators"]),
                    has_evidence=total_matches > 2,
                    fp_risk=0.2,
                )

                chain_findings.append({
                    "title": f"Attack chain: {rule['name']}",
                    "severity": rule["severity"],
                    "category": "chain",
                    "cwe_id": rule["cwe_id"],
                    "description": (
                        f"{rule['description']} "
                        f"Chain confidence: {conf}%. "
                        f"Based on {total_matches} matching finding(s) across "
                        f"{len(matched_indicators)} indicator(s)."
                    ),
                    "evidence": (
                        f"Matched indicators: "
                        + "; ".join(
                            f"{m['indicator']} ({m['matched_count']} findings: {', '.join(m['examples'])})"
                            for m in matched_indicators
                        )
                    ),
                    "remediation": rule["remediation"],
                    "confidence": conf,
                    "chain_name": rule["name"],
                    "indicators_matched": matched_indicators,
                })

        if not chain_findings:
            chain_findings.append({
                "title": f"No exploit chains identified for {target}",
                "severity": "info",
                "category": "info",
                "description": (
                    f"Analyzed {len(existing)} existing findings against {len(CHAIN_RULES)} chain rules. "
                    f"No multi-step attack paths were identified."
                ),
                "evidence": f"Input findings: {len(existing)}, chain rules: {len(CHAIN_RULES)}",
                "remediation": "Continue monitoring. Re-run after new findings are generated.",
            })

        # Sort by severity
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
        chain_findings.sort(key=lambda f: severity_order.get(f.get("severity", "info"), 5))

        logger.info(
            "Exploit chain analysis complete",
            target=target,
            chains_found=len([f for f in chain_findings if f["severity"] != "info"]),
        )
        return chain_findings

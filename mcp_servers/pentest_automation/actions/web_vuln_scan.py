"""Web Vulnerability Scanner action.

Inspired by NeuroSploit's vuln_engine — tests for common web vulnerabilities
including SQLi, XSS, SSRF, LFI, Command Injection, and Open Redirects.
Uses a payload library and response analysis (no active exploitation).
"""

import asyncio
import ipaddress
import ssl
import re
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

# NeuroSploit-inspired payload library (safe detection payloads, not exploits)
VULN_TESTS = {
    "sqli": {
        "name": "SQL Injection",
        "severity": "critical",
        "cwe_id": "CWE-89",
        "payloads": [
            "/?id=1'",
            "/?id=1' OR '1'='1",
            "/?id=1; SELECT 1--",
            "/?id=1 UNION SELECT NULL--",
            "/?search=test' AND '1'='1",
        ],
        "indicators": [
            r"sql syntax",
            r"mysql_fetch",
            r"you have an error in your sql",
            r"unclosed quotation mark",
            r"ORA-\d{5}",
            r"PG::SyntaxError",
            r"sqlite3\.OperationalError",
            r"SQLSTATE\[",
            r"microsoft ole db provider",
            r"odbc.*driver",
            r"syntax error.*near",
        ],
        "description": "SQL Injection allows attackers to manipulate database queries, potentially leading to data theft or unauthorized access.",
        "remediation": "Use parameterized queries/prepared statements. Never concatenate user input into SQL queries.",
    },
    "xss_reflected": {
        "name": "Reflected XSS",
        "severity": "high",
        "cwe_id": "CWE-79",
        "payloads": [
            '/?q=<script>alert("XSS")</script>',
            '/?search="><img src=x onerror=alert(1)>',
            "/?name=<svg/onload=alert(1)>",
            "/?q=javascript:alert(1)",
            "/?redirect=<iframe src=x>",
        ],
        "indicators": [
            r'<script>alert\("XSS"\)</script>',
            r"<img src=x onerror=alert\(1\)>",
            r"<svg/onload=alert\(1\)>",
            r"javascript:alert\(1\)",
            r"<iframe src=x>",
        ],
        "description": "Reflected XSS allows attackers to inject malicious scripts that execute in the user's browser.",
        "remediation": "Encode all output. Use Content-Security-Policy headers. Validate and sanitize input.",
    },
    "lfi": {
        "name": "Local File Inclusion",
        "severity": "high",
        "cwe_id": "CWE-98",
        "payloads": [
            "/?file=../../../../etc/passwd",
            "/?page=....//....//....//etc/passwd",
            "/?include=/etc/passwd",
            "/?path=..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "/?template=php://filter/convert.base64-encode/resource=index",
        ],
        "indicators": [
            r"root:.*:0:0:",
            r"daemon:.*:",
            r"\[boot loader\]",
            r"\[operating systems\]",
            r"PD9waHA",  # base64 of <?php
        ],
        "description": "LFI allows reading arbitrary files from the server, potentially exposing credentials and source code.",
        "remediation": "Use a whitelist of allowed file paths. Never pass user input directly to file operations.",
    },
    "command_injection": {
        "name": "Command Injection",
        "severity": "critical",
        "cwe_id": "CWE-78",
        "payloads": [
            "/?cmd=;id",
            "/?host=127.0.0.1;whoami",
            "/?ip=127.0.0.1|id",
            "/?ping=127.0.0.1`id`",
            "/?exec=test$(id)",
        ],
        "indicators": [
            r"uid=\d+",
            r"gid=\d+",
            r"groups=\d+",
            r"root",
            r"www-data",
        ],
        "description": "Command Injection allows executing arbitrary OS commands on the server.",
        "remediation": "Never pass user input to shell commands. Use language-native APIs instead of exec/system calls.",
    },
    "ssrf": {
        "name": "Server-Side Request Forgery",
        "severity": "high",
        "cwe_id": "CWE-918",
        "payloads": [
            "/?url=http://127.0.0.1",
            "/?url=http://localhost:22",
            "/?url=http://169.254.169.254/latest/meta-data/",
            "/?fetch=http://[::1]",
            "/?callback=http://127.0.0.1:8080",
        ],
        "indicators": [
            r"SSH-\d",
            r"ami-id",
            r"instance-id",
            r"meta-data",
            r"OpenSSH",
            r"Connection refused",
        ],
        "description": "SSRF allows attackers to make the server perform requests to internal services.",
        "remediation": "Validate and whitelist allowed URLs. Block requests to internal IP ranges. Use a URL parser.",
    },
    "open_redirect": {
        "name": "Open Redirect",
        "severity": "medium",
        "cwe_id": "CWE-601",
        "payloads": [
            "/?redirect=https://evil.com",
            "/?next=//evil.com",
            "/?url=https://evil.com",
            "/?return_to=https://evil.com",
            "/?continue=https://evil.com",
        ],
        "indicators": [],  # Check via Location header
        "description": "Open redirects can be used for phishing by redirecting users to malicious sites.",
        "remediation": "Validate redirect URLs against a whitelist. Only allow relative redirects.",
    },
}


def _is_in_scope(target: str) -> bool:
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class WebVulnScanAction:
    """Comprehensive web vulnerability scanner.

    Tests for SQL Injection, XSS, LFI, Command Injection, SSRF, and
    Open Redirects using safe detection payloads. Analyzes responses
    for error messages and reflection patterns that indicate vulnerability.
    Based on NeuroSploit's vuln_engine with payload library.
    """

    action_id = "web_vuln_scan"
    name = "Web Vulnerability Scanner"
    description = "Test for SQLi, XSS, LFI, Command Injection, SSRF, and Open Redirects using NeuroSploit payload library."
    risk_level = "high"
    category = "neurosploit"

    async def execute(self, target: str, port: int = 80, use_tls: bool = False) -> list[dict]:
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs are permitted.",
            }]

        logger.info("Starting web vulnerability scan", target=target, port=port, tls=use_tls)
        findings = []

        # Check baseline connectivity
        baseline = await self._send_request(target, port, use_tls, "/")
        if baseline is None:
            return [{
                "title": f"HTTP{'S' if use_tls else ''} service not responding on port {port}",
                "severity": "info",
                "category": "info",
                "description": f"Could not connect to {target}:{port}.",
            }]

        baseline_status, _, baseline_body = baseline

        # Run all vuln tests concurrently (per category)
        semaphore = asyncio.Semaphore(5)  # Limit concurrent requests
        tasks = []
        for vuln_id, vuln_info in VULN_TESTS.items():
            tasks.append(
                self._test_vuln_category(
                    target, port, use_tls, vuln_id, vuln_info,
                    baseline_status, baseline_body, semaphore
                )
            )

        results = await asyncio.gather(*tasks, return_exceptions=True)
        for result in results:
            if isinstance(result, Exception):
                logger.warning("Vuln test error", error=str(result))
                continue
            findings.extend(result)

        if not findings:
            findings.append({
                "title": f"No web vulnerabilities detected on {target}:{port}",
                "severity": "info",
                "category": "info",
                "description": "All vulnerability tests passed without detecting issues.",
                "evidence": f"Tested {len(VULN_TESTS)} vulnerability categories with {sum(len(v['payloads']) for v in VULN_TESTS.values())} payloads.",
                "remediation": "Continue regular security assessments.",
            })

        logger.info("Web vulnerability scan complete", target=target, finding_count=len(findings))
        return findings

    async def _test_vuln_category(
        self, target: str, port: int, use_tls: bool,
        vuln_id: str, vuln_info: dict,
        baseline_status: int, baseline_body: str,
        semaphore: asyncio.Semaphore,
    ) -> list[dict]:
        findings = []
        positive_payloads = []

        for payload in vuln_info["payloads"]:
            async with semaphore:
                result = await self._send_request(target, port, use_tls, payload)

            if result is None:
                continue

            status, headers, body = result
            is_vulnerable = False

            # Check for indicator patterns in response body
            for pattern in vuln_info.get("indicators", []):
                if re.search(pattern, body, re.IGNORECASE):
                    is_vulnerable = True
                    break

            # For open redirect, check Location header
            if vuln_id == "open_redirect" and status in (301, 302, 303, 307, 308):
                location = headers.get("location", "")
                if "evil.com" in location:
                    is_vulnerable = True

            # Check for verbose error messages (secondary indicator)
            if not is_vulnerable and vuln_id in ("sqli", "command_injection"):
                error_patterns = [
                    r"stack trace", r"traceback", r"exception",
                    r"error in.*line \d+", r"warning:.*on line",
                ]
                for pattern in error_patterns:
                    if re.search(pattern, body, re.IGNORECASE):
                        # Verbose errors — lower severity
                        findings.append({
                            "title": f"Verbose error disclosure on {target}:{port}",
                            "severity": "low",
                            "category": "exposure",
                            "cwe_id": "CWE-209",
                            "description": "The server returns detailed error messages that may reveal internal structure.",
                            "evidence": f"Payload: {payload}\nResponse contains error details.",
                            "remediation": "Disable verbose errors in production. Use generic error pages.",
                        })
                        break

            if is_vulnerable:
                positive_payloads.append(payload)

        if positive_payloads:
            findings.append({
                "title": f"{vuln_info['name']} detected on {target}:{port}",
                "severity": vuln_info["severity"],
                "category": "vuln",
                "cwe_id": vuln_info.get("cwe_id"),
                "description": vuln_info["description"],
                "evidence": (
                    f"Vulnerability: {vuln_info['name']}\n"
                    f"Positive payloads ({len(positive_payloads)}/{len(vuln_info['payloads'])}):\n"
                    + "\n".join(f"  - {p}" for p in positive_payloads)
                ),
                "remediation": vuln_info["remediation"],
            })

        return findings

    async def _send_request(
        self, target: str, port: int, use_tls: bool, path: str
    ) -> tuple[int, dict, str] | None:
        try:
            if use_tls:
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port, ssl=ctx), timeout=8
                )
            else:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port), timeout=8
                )

            request = (
                f"GET {path} HTTP/1.1\r\n"
                f"Host: {target}\r\n"
                f"Connection: close\r\n"
                f"User-Agent: Mozilla/5.0 (compatible; SecurityAudit/1.0)\r\n"
                f"\r\n"
            )
            writer.write(request.encode())
            await writer.drain()

            data = await asyncio.wait_for(reader.read(16384), timeout=8)
            response = data.decode("utf-8", errors="replace")
            writer.close()
            await writer.wait_closed()

            status_code = 0
            headers = {}
            lines = response.split("\r\n")
            if lines:
                parts = lines[0].split(" ", 2)
                if len(parts) >= 2:
                    try:
                        status_code = int(parts[1])
                    except ValueError:
                        pass

            body_start = False
            body = ""
            for line in lines[1:]:
                if body_start:
                    body += line + "\n"
                elif line == "":
                    body_start = True
                elif ":" in line:
                    key, _, value = line.partition(":")
                    headers[key.strip().lower()] = value.strip()

            return status_code, headers, body.strip()

        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return None

"""Web Vulnerability Probe action â€” NeuroSploit-derived.

Runs 8 concurrent check categories: CORS misconfiguration, clickjacking,
sensitive path exposure, directory listing, XSS reflection, SQLi error
detection, open redirect, and stack trace / debug disclosure.
"""

import asyncio
import re
import structlog

from mcp_servers.pentest_automation.actions.neurosploit_utils import (
    is_in_scope,
    out_of_scope_finding,
    confidence_score,
    async_http_request,
)

logger = structlog.get_logger()

# Sensitive paths to probe
SENSITIVE_PATHS = [
    "/.env",
    "/.git/HEAD",
    "/phpinfo.php",
    "/server-status",
    "/server-info",
    "/.htaccess",
    "/.htpasswd",
    "/web.config",
    "/wp-config.php.bak",
    "/config.php.bak",
    "/.DS_Store",
    "/crossdomain.xml",
    "/elmah.axd",
]

# SQL error patterns (12 regex patterns covering major databases)
SQLI_ERROR_PATTERNS = [
    (r"you have an error in your sql syntax", "MySQL"),
    (r"warning.*?\bmysql", "MySQL"),
    (r"unclosed quotation mark after the character string", "MSSQL"),
    (r"microsoft ole db provider for sql server", "MSSQL"),
    (r"pg_query\(\)|pg_exec\(\)|postgresql.*?error", "PostgreSQL"),
    (r"unterminated quoted string at or near", "PostgreSQL"),
    (r"ora-\d{5}", "Oracle"),
    (r"oracle.*?driver.*?error", "Oracle"),
    (r"sqlite3\.operationalerror", "SQLite"),
    (r"near \".*?\": syntax error", "SQLite"),
    (r"jdbc\.sql\.sqlexception", "Java/JDBC"),
    (r"odbc sql server driver", "MSSQL/ODBC"),
]

# Stack trace / debug disclosure patterns
DEBUG_PATTERNS = [
    (r"traceback \(most recent call last\)", "Python traceback", "CWE-209"),
    (r"at [\w.]+\([\w]+\.java:\d+\)", "Java stack trace", "CWE-209"),
    (r"django\.core\.exceptions", "Django debug page", "CWE-209"),
    (r"<b>notice</b>:.*?<b>", "PHP notice/warning", "CWE-209"),
    (r"<b>fatal error</b>:", "PHP fatal error", "CWE-209"),
    (r"node_modules/.+?\.js:\d+", "Node.js stack trace", "CWE-209"),
    (r"actioncontroller::routingerror", "Rails routing error", "CWE-209"),
    (r"asp\.net.*?unhandled exception", "ASP.NET error", "CWE-209"),
    (r"<pre class=\"cake-error\">", "CakePHP debug", "CWE-209"),
]

# Canary string for XSS reflection test
XSS_CANARY = "n3ur0sp10it7x55"


class WebVulnProbeAction:
    """Probe for common web vulnerabilities across 8 categories."""

    action_id = "web_vuln_probe"
    name = "Web Vulnerability Probe"
    description = "Probe for CORS, clickjacking, sensitive paths, directory listing, XSS, SQLi, open redirect, and debug disclosure."
    risk_level = "medium"

    async def execute(self, target: str, port: int = 80, use_tls: bool = False, on_progress=None) -> list[dict]:
        if not is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [out_of_scope_finding(target)]

        async def emit(msg: str):
            if on_progress:
                await on_progress(msg)

        logger.info("Starting web vuln probe", target=target, port=port, tls=use_tls)

        await emit("Checking CORS configuration...")
        await emit("Testing clickjacking protection...")
        await emit(f"Probing {len(SENSITIVE_PATHS)} sensitive paths...")
        await emit("Checking directory listing...")
        await emit("Testing XSS reflection...")
        await emit("Checking SQLi error disclosure...")
        await emit("Testing open redirect...")
        await emit("Checking debug disclosure...")

        # Run all 8 check categories concurrently
        checks = [
            self._check_cors(target, port, use_tls),
            self._check_clickjacking(target, port, use_tls),
            self._check_sensitive_paths(target, port, use_tls),
            self._check_directory_listing(target, port, use_tls),
            self._check_xss_reflection(target, port, use_tls),
            self._check_sqli_errors(target, port, use_tls),
            self._check_open_redirect(target, port, use_tls),
            self._check_debug_disclosure(target, port, use_tls),
        ]

        results = await asyncio.gather(*checks, return_exceptions=True)

        findings = []
        check_names = [
            "CORS", "clickjacking", "sensitive_paths", "directory_listing",
            "xss_reflection", "sqli_errors", "open_redirect", "debug_disclosure",
        ]
        for name, result in zip(check_names, results):
            if isinstance(result, Exception):
                logger.debug("Vuln check failed", check=name, error=str(result))
                continue
            findings.extend(result)

        if not findings:
            findings.append({
                "title": f"No web vulnerabilities detected on {target}:{port}",
                "severity": "info",
                "category": "info",
                "description": "All 8 vulnerability checks passed without findings.",
                "evidence": f"Checks run: {check_names}",
                "remediation": "No action required. Continue regular security assessments.",
            })

        logger.info("Web vuln probe complete", target=target, findings=len(findings))
        return findings

    async def _check_cors(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Check for CORS misconfiguration (reflects arbitrary Origin)."""
        evil_origin = "https://evil.attacker.com"
        status, headers, _ = await async_http_request(
            target, port, "/", use_tls=use_tls,
            headers={"Origin": evil_origin},
        )
        if status is None:
            return []

        acao = headers.get("access-control-allow-origin", "")
        acac = headers.get("access-control-allow-credentials", "").lower()

        findings = []
        if evil_origin in acao:
            severity = "high" if acac == "true" else "medium"
            conf = confidence_score(2 if acac == "true" else 1, 2, has_evidence=True, fp_risk=0.1)
            findings.append({
                "title": "CORS misconfiguration: arbitrary origin reflected",
                "severity": severity,
                "category": "vuln",
                "cwe_id": "CWE-942",
                "description": (
                    f"The server reflects arbitrary Origin headers in Access-Control-Allow-Origin. "
                    f"Credentials allowed: {acac == 'true'}. "
                    f"This enables cross-origin data theft from authenticated sessions."
                ),
                "evidence": f"Origin: {evil_origin} -> ACAO: {acao}, ACAC: {acac}",
                "remediation": "Configure CORS to allow only trusted origins. Never reflect arbitrary origins with credentials.",
                "confidence": conf,
            })
        elif acao == "*":
            findings.append({
                "title": "CORS: wildcard Access-Control-Allow-Origin",
                "severity": "low",
                "category": "misconfig",
                "cwe_id": "CWE-942",
                "description": "CORS allows all origins (*). While browsers prevent credential sharing with *, public data may be scraped.",
                "evidence": f"ACAO: {acao}",
                "remediation": "Restrict ACAO to specific trusted origins if the API serves sensitive data.",
                "confidence": confidence_score(1, 2, has_evidence=True, fp_risk=0.3),
            })

        return findings

    async def _check_clickjacking(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Check for missing clickjacking protections."""
        status, headers, _ = await async_http_request(target, port, "/", use_tls=use_tls)
        if status is None:
            return []

        xfo = headers.get("x-frame-options", "")
        csp = headers.get("content-security-policy", "")
        has_frame_ancestors = "frame-ancestors" in csp

        if not xfo and not has_frame_ancestors:
            return [{
                "title": "Clickjacking protection missing",
                "severity": "medium",
                "category": "misconfig",
                "cwe_id": "CWE-1021",
                "description": "Neither X-Frame-Options nor CSP frame-ancestors is set. The page can be embedded in iframes for clickjacking.",
                "evidence": f"X-Frame-Options: absent, CSP frame-ancestors: absent",
                "remediation": "Add X-Frame-Options: DENY (or SAMEORIGIN) and CSP frame-ancestors directive.",
                "confidence": confidence_score(2, 2, has_evidence=True, fp_risk=0.1),
            }]
        return []

    async def _check_sensitive_paths(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Probe for exposed sensitive files and paths."""
        tasks = [
            async_http_request(target, port, path, use_tls=use_tls, timeout=6)
            for path in SENSITIVE_PATHS
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        findings = []
        for path, result in zip(SENSITIVE_PATHS, results):
            if isinstance(result, Exception):
                continue
            status, _, body = result
            if status is not None and status == 200 and len(body) > 10:
                severity = "high" if path in ("/.env", "/.git/HEAD", "/.htpasswd") else "medium"
                findings.append({
                    "title": f"Sensitive path exposed: {path}",
                    "severity": severity,
                    "category": "exposure",
                    "cwe_id": "CWE-538",
                    "description": f"Sensitive file or path '{path}' returned HTTP 200 with content.",
                    "evidence": f"GET {path} -> 200, body length: {len(body)}, preview: {body[:100]}",
                    "remediation": f"Block access to {path} via web server configuration or remove the file.",
                    "confidence": confidence_score(1, 1, has_evidence=True, fp_risk=0.2),
                })
        return findings

    async def _check_directory_listing(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Detect directory listing on common paths."""
        test_paths = ["/", "/images/", "/uploads/", "/static/", "/assets/"]
        tasks = [
            async_http_request(target, port, p, use_tls=use_tls, timeout=6)
            for p in test_paths
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        findings = []
        for path, result in zip(test_paths, results):
            if isinstance(result, Exception):
                continue
            status, _, body = result
            if status == 200 and body:
                body_lower = body.lower()
                if "index of /" in body_lower or "directory listing" in body_lower or "<pre>name" in body_lower:
                    findings.append({
                        "title": f"Directory listing enabled: {path}",
                        "severity": "medium",
                        "category": "misconfig",
                        "cwe_id": "CWE-548",
                        "description": f"Directory listing is enabled at '{path}', exposing file and directory names.",
                        "evidence": f"GET {path} -> 200 with directory listing content",
                        "remediation": "Disable directory listing in web server configuration.",
                        "confidence": confidence_score(1, 1, has_evidence=True, fp_risk=0.1),
                    })
        return findings

    async def _check_xss_reflection(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Check for XSS reflection using a canary string."""
        test_paths = [
            f"/?q={XSS_CANARY}",
            f"/?search={XSS_CANARY}",
            f"/?name={XSS_CANARY}",
        ]
        tasks = [
            async_http_request(target, port, p, use_tls=use_tls, timeout=6)
            for p in test_paths
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        findings = []
        for path, result in zip(test_paths, results):
            if isinstance(result, Exception):
                continue
            status, _, body = result
            if status is not None and XSS_CANARY in body:
                param = path.split("=")[0].split("?")[1]
                findings.append({
                    "title": f"Potential XSS: input reflected in response (param: {param})",
                    "severity": "medium",
                    "category": "vuln",
                    "cwe_id": "CWE-79",
                    "description": (
                        f"Parameter '{param}' reflects user input in the response body. "
                        f"This may be exploitable for reflected XSS if output is unescaped."
                    ),
                    "evidence": f"Canary '{XSS_CANARY}' found in response body for {path}",
                    "remediation": "Sanitize and encode all user input before rendering in HTML responses.",
                    "confidence": confidence_score(1, 1, has_evidence=True, fp_risk=0.3),
                })
                break  # One finding is enough
        return findings

    async def _check_sqli_errors(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Check for SQL injection error disclosure."""
        test_paths = [
            "/?id=1'",
            "/?id=1%27%20OR%201%3D1--",
            "/?id=1 AND 1=CONVERT(int,@@version)--",
        ]
        tasks = [
            async_http_request(target, port, p, use_tls=use_tls, timeout=6)
            for p in test_paths
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        findings = []
        for path, result in zip(test_paths, results):
            if isinstance(result, Exception):
                continue
            status, _, body = result
            if not body:
                continue
            body_lower = body.lower()
            for pattern, db_type in SQLI_ERROR_PATTERNS:
                if re.search(pattern, body_lower):
                    findings.append({
                        "title": f"SQL error disclosure detected ({db_type})",
                        "severity": "high",
                        "category": "vuln",
                        "cwe_id": "CWE-89",
                        "description": (
                            f"A {db_type} SQL error was triggered by a test payload. "
                            f"This strongly indicates SQL injection vulnerability."
                        ),
                        "evidence": f"Pattern '{pattern}' matched in response to {path}",
                        "remediation": "Use parameterized queries. Never concatenate user input into SQL statements.",
                        "confidence": confidence_score(1, 1, has_evidence=True, fp_risk=0.1),
                    })
                    return findings  # One SQLi finding is sufficient
        return findings

    async def _check_open_redirect(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Check for open redirect via common redirect parameters."""
        test_paths = [
            "/?next=https://evil.com",
            "/?redirect=https://evil.com",
            "/?url=https://evil.com",
            "/?return_to=https://evil.com",
        ]
        tasks = [
            async_http_request(target, port, p, use_tls=use_tls, timeout=6)
            for p in test_paths
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        findings = []
        for path, result in zip(test_paths, results):
            if isinstance(result, Exception):
                continue
            status, headers, _ = result
            if status is not None and status in (301, 302, 303, 307, 308):
                location = headers.get("location", "")
                if "evil.com" in location:
                    param = path.split("=")[0].split("?")[1]
                    findings.append({
                        "title": f"Open redirect via '{param}' parameter",
                        "severity": "medium",
                        "category": "vuln",
                        "cwe_id": "CWE-601",
                        "description": (
                            f"Parameter '{param}' causes a redirect to an external domain. "
                            f"This can be used for phishing attacks."
                        ),
                        "evidence": f"{path} -> {status} Location: {location}",
                        "remediation": "Validate redirect URLs against a whitelist of allowed domains.",
                        "confidence": confidence_score(1, 1, has_evidence=True, fp_risk=0.1),
                    })
                    return findings  # One is enough
        return findings

    async def _check_debug_disclosure(self, target: str, port: int, use_tls: bool) -> list[dict]:
        """Check for stack trace and debug information disclosure."""
        # Request paths likely to trigger errors
        test_paths = [
            "/nonexistent_path_trigger_404",
            "/%00",
            "/?debug=1",
        ]
        tasks = [
            async_http_request(target, port, p, use_tls=use_tls, timeout=6)
            for p in test_paths
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        findings = []
        for path, result in zip(test_paths, results):
            if isinstance(result, Exception):
                continue
            status, _, body = result
            if not body:
                continue
            body_lower = body.lower()
            for pattern, desc, cwe in DEBUG_PATTERNS:
                if re.search(pattern, body_lower):
                    findings.append({
                        "title": f"Debug/stack trace disclosure: {desc}",
                        "severity": "medium",
                        "category": "exposure",
                        "cwe_id": cwe,
                        "description": (
                            f"Server exposes {desc} in error responses. "
                            f"This leaks internal implementation details useful to attackers."
                        ),
                        "evidence": f"Pattern '{pattern}' matched in response to {path}",
                        "remediation": "Disable debug mode in production. Configure custom error pages.",
                        "confidence": confidence_score(1, 1, has_evidence=True, fp_risk=0.15),
                    })
                    return findings  # One finding is enough
        return findings

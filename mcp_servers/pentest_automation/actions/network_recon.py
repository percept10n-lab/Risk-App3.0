"""Network Reconnaissance action.

Inspired by NeuroSploit's recon_integration â€” performs network-level
reconnaissance including ICMP probing, TCP SYN checks, OS fingerprinting
hints via TTL analysis, and common network service enumeration.
"""

import asyncio
import ipaddress
import socket
import struct
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

# OS fingerprinting hints via TTL values
TTL_OS_HINTS = {
    (60, 64): "Linux/Unix/macOS",
    (120, 128): "Windows",
    (250, 255): "Network Device (Router/Switch/Firewall)",
}

# Extended port list for network recon
RECON_PORTS = {
    # Infrastructure
    22: "SSH",
    23: "Telnet",
    53: "DNS",
    67: "DHCP Server",
    80: "HTTP",
    443: "HTTPS",
    # Network services
    137: "NetBIOS Name",
    138: "NetBIOS Datagram",
    139: "NetBIOS Session",
    445: "SMB",
    # Management
    161: "SNMP",
    162: "SNMP Trap",
    8080: "HTTP Proxy",
    8443: "HTTPS Alt",
    9090: "Management",
    # IoT / Home
    1883: "MQTT",
    5353: "mDNS",
    8883: "MQTT TLS",
    1900: "UPnP/SSDP",
    # Media
    8096: "Jellyfin",
    32400: "Plex",
    # Databases
    3306: "MySQL",
    5432: "PostgreSQL",
    6379: "Redis",
    27017: "MongoDB",
}


def _is_in_scope(target: str) -> bool:
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class NetworkReconAction:
    """Network-level reconnaissance and host profiling.

    Combines TCP port probing, TTL-based OS fingerprinting hints,
    network service enumeration, and subnet host discovery.
    Based on NeuroSploit's recon_integration module.
    """

    action_id = "network_recon"
    name = "Network Reconnaissance"
    description = "Network-level recon: extended port scan, OS hints via TTL, subnet discovery, and service mapping."
    risk_level = "low"
    category = "neurosploit"

    async def execute(self, target: str, scan_neighbors: bool = False) -> list[dict]:
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs are permitted.",
            }]

        logger.info("Starting network reconnaissance", target=target)
        findings = []

        # Phase 1: Extended TCP port scan
        open_ports = await self._scan_ports(target)

        if open_ports:
            # Categorize services
            infra_services = []
            mgmt_services = []
            data_services = []
            iot_services = []
            media_services = []

            for port in open_ports:
                svc_name = RECON_PORTS.get(port, f"Unknown ({port})")
                entry = f"{port}/{svc_name}"

                if port in (22, 23, 53, 67, 80, 443, 137, 138, 139, 445):
                    infra_services.append(entry)
                elif port in (161, 162, 8080, 8443, 9090):
                    mgmt_services.append(entry)
                elif port in (3306, 5432, 6379, 27017):
                    data_services.append(entry)
                elif port in (1883, 5353, 8883, 1900):
                    iot_services.append(entry)
                elif port in (8096, 32400):
                    media_services.append(entry)
                else:
                    infra_services.append(entry)

            # Overall port scan finding
            findings.append({
                "title": f"{len(open_ports)} open ports on {target}",
                "severity": "info",
                "category": "info",
                "description": f"Extended port scan found {len(open_ports)} open ports.",
                "evidence": (
                    f"Open ports on {target}:\n"
                    + (f"\nInfrastructure: {', '.join(infra_services)}" if infra_services else "")
                    + (f"\nManagement: {', '.join(mgmt_services)}" if mgmt_services else "")
                    + (f"\nDatabases: {', '.join(data_services)}" if data_services else "")
                    + (f"\nIoT/Home: {', '.join(iot_services)}" if iot_services else "")
                    + (f"\nMedia: {', '.join(media_services)}" if media_services else "")
                ),
            })

            # Security findings for exposed services
            if data_services:
                findings.append({
                    "title": f"Database services exposed on {target}",
                    "severity": "high",
                    "category": "exposure",
                    "description": "Database services are directly accessible on the network. They should be firewalled.",
                    "evidence": f"Exposed databases: {', '.join(data_services)}",
                    "remediation": "Bind databases to localhost (127.0.0.1). Use firewall rules to restrict access.",
                })

            if 161 in open_ports:
                findings.append({
                    "title": f"SNMP service exposed on {target}:161",
                    "severity": "medium",
                    "category": "exposure",
                    "description": "SNMP can leak extensive device information and may allow configuration changes.",
                    "evidence": "SNMP port 161 is open.",
                    "remediation": "Disable SNMP if not needed. If needed, use SNMPv3 with authentication and encryption.",
                })

            if 23 in open_ports:
                findings.append({
                    "title": f"Telnet service exposed on {target}:23",
                    "severity": "high",
                    "category": "exposure",
                    "description": "Telnet transmits all data including credentials in cleartext.",
                    "evidence": "Telnet port 23 is open.",
                    "remediation": "Disable Telnet and use SSH instead.",
                })

            if 445 in open_ports or 139 in open_ports:
                findings.append({
                    "title": f"SMB/NetBIOS services on {target}",
                    "severity": "medium",
                    "category": "exposure",
                    "description": "SMB file sharing is accessible. Ensure proper access controls are in place.",
                    "evidence": f"SMB ports: {', '.join(str(p) for p in open_ports if p in (139, 445))}",
                    "remediation": "Disable SMBv1. Require authentication for all shares. Consider disabling if not needed.",
                })

            if 1883 in open_ports:
                findings.append({
                    "title": f"MQTT broker exposed on {target}:1883",
                    "severity": "medium",
                    "category": "exposure",
                    "description": "MQTT broker is accessible without TLS. IoT message traffic may be intercepted.",
                    "evidence": "MQTT port 1883 is open (unencrypted).",
                    "remediation": "Use MQTT over TLS (port 8883). Require authentication for all MQTT clients.",
                })

        # Phase 2: OS fingerprinting via TTL
        os_hint = await self._get_ttl_hint(target)
        if os_hint:
            ttl, os_guess = os_hint
            findings.append({
                "title": f"OS fingerprint hint: {os_guess}",
                "severity": "info",
                "category": "info",
                "description": f"TTL-based OS fingerprinting suggests {os_guess}.",
                "evidence": f"TTL value: {ttl} -> {os_guess}",
                "remediation": "This is informational. Consider hardening based on the detected OS.",
            })

        # Phase 3: Host profile summary
        profile = self._build_profile(target, open_ports, os_hint)
        if profile:
            findings.append({
                "title": f"Host profile: {profile['type']}",
                "severity": "info",
                "category": "info",
                "description": f"Based on open ports and services, this device appears to be: {profile['type']}",
                "evidence": (
                    f"Device type: {profile['type']}\n"
                    f"Confidence: {profile['confidence']}\n"
                    f"Key indicators: {', '.join(profile['indicators'])}"
                ),
            })

        if not findings:
            findings.append({
                "title": f"No network information gathered for {target}",
                "severity": "info",
                "category": "info",
                "description": "Target did not respond to any probes.",
            })

        logger.info("Network recon complete", target=target, open_ports=len(open_ports))
        return findings

    async def _scan_ports(self, target: str) -> list[int]:
        """Scan extended port list."""
        open_ports = []
        semaphore = asyncio.Semaphore(50)

        async def check_port(port: int):
            async with semaphore:
                try:
                    _, writer = await asyncio.wait_for(
                        asyncio.open_connection(target, port), timeout=3
                    )
                    writer.close()
                    await writer.wait_closed()
                    open_ports.append(port)
                except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
                    pass

        tasks = [check_port(p) for p in RECON_PORTS.keys()]
        await asyncio.gather(*tasks, return_exceptions=True)

        return sorted(open_ports)

    async def _get_ttl_hint(self, target: str) -> tuple[int, str] | None:
        """Try to determine OS via TCP connection TTL."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_TTL, 128)

            loop = asyncio.get_event_loop()

            # Try connecting to a likely open port
            for port in [80, 443, 22, 8080]:
                try:
                    await asyncio.wait_for(
                        loop.run_in_executor(None, sock.connect, (target, port)),
                        timeout=3,
                    )

                    # Get TTL from socket options
                    ttl = sock.getsockopt(socket.IPPROTO_IP, socket.IP_TTL)
                    sock.close()

                    for (low, high), os_name in TTL_OS_HINTS.items():
                        if low <= ttl <= high:
                            return ttl, os_name
                    return ttl, f"Unknown (TTL={ttl})"
                except (ConnectionRefusedError, OSError):
                    continue

            sock.close()
        except (OSError, asyncio.TimeoutError):
            pass

        return None

    def _build_profile(
        self, target: str, open_ports: list[int], os_hint: tuple | None
    ) -> dict | None:
        """Build a device profile based on collected information."""
        if not open_ports:
            return None

        port_set = set(open_ports)

        # Router/Firewall indicators
        if port_set & {53, 67, 80, 443} and len(port_set & {53, 67}) >= 1:
            return {
                "type": "Router / Gateway",
                "confidence": "high" if 67 in port_set else "medium",
                "indicators": [f"Port {p}" for p in sorted(port_set & {53, 67, 80, 443})],
            }

        # NAS/Storage
        if port_set & {139, 445, 80} and len(port_set & {139, 445}) >= 1:
            return {
                "type": "NAS / File Server",
                "confidence": "medium",
                "indicators": [f"Port {p}" for p in sorted(port_set & {139, 445, 80, 443})],
            }

        # IoT Hub
        if port_set & {1883, 8883, 1900, 5353}:
            return {
                "type": "IoT Hub / Smart Home Controller",
                "confidence": "medium",
                "indicators": [f"Port {p}" for p in sorted(port_set & {1883, 8883, 1900, 5353})],
            }

        # Media Server
        if port_set & {32400, 8096}:
            return {
                "type": "Media Server",
                "confidence": "high",
                "indicators": [f"Port {p}" for p in sorted(port_set & {32400, 8096})],
            }

        # General Server
        if port_set & {22, 80, 443}:
            return {
                "type": "Server / Workstation",
                "confidence": "low",
                "indicators": [f"Port {p}" for p in sorted(port_set & {22, 80, 443})],
            }

        return {
            "type": "Unknown Device",
            "confidence": "low",
            "indicators": [f"{len(open_ports)} open ports"],
        }

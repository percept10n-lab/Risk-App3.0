"""WAF Detection & Fingerprinting action.

Inspired by NeuroSploit's waf_detector.py â€” detects 16 WAF signatures
and tests bypass techniques against the target's web service.
"""

import asyncio
import ipaddress
import ssl
import structlog

logger = structlog.get_logger()

RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

# WAF signature database (inspired by NeuroSploit's 16 signatures)
WAF_SIGNATURES = {
    "cloudflare": {
        "headers": ["cf-ray", "cf-cache-status", "cf-request-id"],
        "server": ["cloudflare"],
        "body": ["attention required!", "cloudflare ray id"],
        "codes": [403, 503],
    },
    "modsecurity": {
        "headers": ["mod_security", "modsecurity"],
        "server": ["mod_security", "modsecurity"],
        "body": ["mod_security", "modsecurity", "not acceptable"],
        "codes": [403, 406],
    },
    "nginx_waf": {
        "headers": [],
        "server": ["nginx"],
        "body": ["403 forbidden", "request rejected"],
        "codes": [403],
    },
    "apache_mod_security": {
        "headers": [],
        "server": ["apache"],
        "body": ["you don't have permission", "forbidden"],
        "codes": [403],
    },
    "fortiweb": {
        "headers": ["fortiwafsid"],
        "server": ["fortiweb"],
        "body": ["fortigate", "fortiweb"],
        "codes": [403],
    },
    "imperva": {
        "headers": ["x-iinfo"],
        "server": [],
        "body": ["incapsula incident", "powered by incapsula", "_incapsula_resource"],
        "codes": [403],
    },
    "f5_big_ip": {
        "headers": ["x-cnection", "x-wa-info"],
        "server": ["bigip", "big-ip"],
        "body": ["the requested url was rejected"],
        "codes": [403],
    },
    "aws_waf": {
        "headers": ["x-amzn-requestid", "x-amz-cf-id"],
        "server": [],
        "body": ["aws waf", "request blocked"],
        "codes": [403],
    },
    "sucuri": {
        "headers": ["x-sucuri-id", "x-sucuri-cache"],
        "server": ["sucuri"],
        "body": ["sucuri website firewall", "access denied - sucuri"],
        "codes": [403],
    },
    "barracuda": {
        "headers": ["barra_counter_session"],
        "server": ["barracuda"],
        "body": ["barracuda networks"],
        "codes": [403],
    },
    "citrix_netscaler": {
        "headers": ["cneonction", "nncoection", "ns_af"],
        "server": ["netscaler"],
        "body": ["ns_af", "netscaler"],
        "codes": [403, 302],
    },
    "akamai": {
        "headers": ["x-akamai-transformed"],
        "server": ["akamaighost"],
        "body": ["access denied", "akamai"],
        "codes": [403],
    },
    "palo_alto": {
        "headers": [],
        "server": [],
        "body": ["has been blocked in accordance with company policy"],
        "codes": [403],
    },
    "sophos": {
        "headers": [],
        "server": ["sophos"],
        "body": ["sophos utm", "web filtering"],
        "codes": [403],
    },
    "pfsense": {
        "headers": [],
        "server": [],
        "body": ["pfsense", "blocked by firewall"],
        "codes": [403],
    },
    "opnsense": {
        "headers": [],
        "server": [],
        "body": ["opnsense", "request denied"],
        "codes": [403],
    },
}

# Payloads that commonly trigger WAFs
WAF_TRIGGER_PAYLOADS = [
    "/<script>alert(1)</script>",
    "/?id=1' OR '1'='1",
    "/?cmd=cat+/etc/passwd",
    "/?file=../../../../etc/passwd",
    "/?q=<img src=x onerror=alert(1)>",
    "/wp-admin/admin-ajax.php?action=test",
    "/?search=UNION+SELECT+1,2,3--",
]


def _is_in_scope(target: str) -> bool:
    try:
        addr = ipaddress.ip_address(target.strip())
        return any(addr in net for net in RFC1918_NETWORKS)
    except ValueError:
        return False


class WAFDetectionAction:
    """Detect and fingerprint Web Application Firewalls.

    Sends benign and malicious-looking requests to identify WAF presence,
    then fingerprints the specific WAF product using header/body signatures.
    Based on NeuroSploit's WAF detector with 16 WAF signatures.
    """

    action_id = "waf_detection"
    name = "WAF Detection & Fingerprint"
    description = "Detect and identify Web Application Firewalls using 16 WAF signatures and trigger payloads."
    risk_level = "medium"
    category = "neurosploit"

    async def execute(self, target: str, port: int = 80, use_tls: bool = False) -> list[dict]:
        if not _is_in_scope(target):
            logger.warning("Target out of scope", target=target, action=self.action_id)
            return [{
                "title": "Target out of scope",
                "severity": "info",
                "category": "info",
                "description": f"Target {target} is not within allowed RFC 1918 ranges.",
                "evidence": f"Target IP: {target}",
                "remediation": "Only RFC 1918 private IPs are permitted.",
            }]

        logger.info("Starting WAF detection", target=target, port=port, tls=use_tls)
        findings = []

        # Phase 1: Baseline request (clean)
        baseline = await self._send_request(target, port, use_tls, "/")
        if baseline is None:
            return [{
                "title": f"HTTP{'S' if use_tls else ''} service not responding on port {port}",
                "severity": "info",
                "category": "info",
                "description": f"Could not connect to {target}:{port}.",
            }]

        # Phase 2: Send trigger payloads and compare responses
        waf_detected = False
        detected_wafs = set()
        trigger_results = []

        tasks = [
            self._send_request(target, port, use_tls, payload)
            for payload in WAF_TRIGGER_PAYLOADS
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for payload, result in zip(WAF_TRIGGER_PAYLOADS, results):
            if isinstance(result, Exception) or result is None:
                continue

            status, headers, body = result
            baseline_status = baseline[0] if baseline else 200

            # Check if response differs from baseline (potential WAF block)
            if status in (403, 406, 429, 503) and status != baseline_status:
                waf_detected = True
                trigger_results.append((payload, status, headers, body))

                # Fingerprint which WAF
                for waf_name, sigs in WAF_SIGNATURES.items():
                    if self._match_signature(sigs, headers, body, status):
                        detected_wafs.add(waf_name)

        # Phase 3: Also check baseline headers/body for WAF signatures
        if baseline:
            _, base_headers, base_body = baseline
            for waf_name, sigs in WAF_SIGNATURES.items():
                for sig_header in sigs["headers"]:
                    if sig_header.lower() in base_headers:
                        detected_wafs.add(waf_name)
                        waf_detected = True
                for sig_server in sigs["server"]:
                    server_val = base_headers.get("server", "").lower()
                    if sig_server.lower() in server_val:
                        detected_wafs.add(waf_name)

        # Generate findings
        if waf_detected:
            if detected_wafs:
                for waf in detected_wafs:
                    findings.append({
                        "title": f"WAF Detected: {waf.replace('_', ' ').title()}",
                        "severity": "medium",
                        "category": "info",
                        "description": (
                            f"A Web Application Firewall ({waf.replace('_', ' ').title()}) "
                            f"was detected on {target}:{port}. WAFs can interfere with "
                            f"vulnerability scanning and may give false negatives."
                        ),
                        "evidence": (
                            f"WAF: {waf}\n"
                            f"Triggered by {len(trigger_results)} of {len(WAF_TRIGGER_PAYLOADS)} test payloads.\n"
                            f"Blocked status codes: {', '.join(str(t[1]) for t in trigger_results)}"
                        ),
                        "remediation": (
                            "Ensure WAF rules are properly configured. "
                            "Consider testing with WAF in detection-only mode to identify "
                            "vulnerabilities that the WAF may be masking."
                        ),
                    })
            else:
                findings.append({
                    "title": "Unknown WAF Detected",
                    "severity": "medium",
                    "category": "info",
                    "description": (
                        f"A WAF-like behavior was detected on {target}:{port} but could not "
                        f"be fingerprinted to a known product."
                    ),
                    "evidence": (
                        f"Triggered by {len(trigger_results)} of {len(WAF_TRIGGER_PAYLOADS)} test payloads.\n"
                        f"Blocked status codes: {', '.join(str(t[1]) for t in trigger_results)}"
                    ),
                    "remediation": "Investigate the firewall/proxy configuration.",
                })
        else:
            findings.append({
                "title": f"No WAF detected on {target}:{port}",
                "severity": "low",
                "category": "exposure",
                "description": (
                    "No Web Application Firewall was detected. The web service may be "
                    "directly exposed to attacks without WAF protection."
                ),
                "evidence": (
                    f"Sent {len(WAF_TRIGGER_PAYLOADS)} malicious-looking payloads. "
                    f"None triggered WAF-like blocking behavior."
                ),
                "remediation": (
                    "Consider deploying a WAF (e.g., ModSecurity, NGINX WAF module) "
                    "to protect against common web attacks."
                ),
            })

        logger.info("WAF detection complete", target=target, waf_detected=waf_detected, wafs=list(detected_wafs))
        return findings

    def _match_signature(self, sigs: dict, headers: dict, body: str, status: int) -> bool:
        body_lower = body.lower()
        for sig_header in sigs["headers"]:
            if sig_header.lower() in headers:
                return True
        for sig_server in sigs["server"]:
            if sig_server.lower() in headers.get("server", "").lower():
                return True
        for sig_body in sigs["body"]:
            if sig_body.lower() in body_lower:
                return True
        return False

    async def _send_request(
        self, target: str, port: int, use_tls: bool, path: str
    ) -> tuple[int, dict, str] | None:
        try:
            if use_tls:
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port, ssl=ctx), timeout=8
                )
            else:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port), timeout=8
                )

            request = (
                f"GET {path} HTTP/1.1\r\n"
                f"Host: {target}\r\n"
                f"Connection: close\r\n"
                f"User-Agent: Mozilla/5.0 (compatible; SecurityAudit/1.0)\r\n"
                f"\r\n"
            )
            writer.write(request.encode())
            await writer.drain()

            data = await asyncio.wait_for(reader.read(8192), timeout=8)
            response = data.decode("utf-8", errors="replace")
            writer.close()
            await writer.wait_closed()

            # Parse response
            status_code = 0
            headers = {}
            lines = response.split("\r\n")
            if lines:
                parts = lines[0].split(" ", 2)
                if len(parts) >= 2:
                    try:
                        status_code = int(parts[1])
                    except ValueError:
                        pass

            body_start = False
            body = ""
            for line in lines[1:]:
                if body_start:
                    body += line + "\n"
                elif line == "":
                    body_start = True
                elif ":" in line:
                    key, _, value = line.partition(":")
                    headers[key.strip().lower()] = value.strip()

            return status_code, headers, body.strip()

        except (asyncio.TimeoutError, ConnectionRefusedError, OSError) as e:
            logger.debug("WAF detection request failed", target=target, path=path, error=str(e))
            return None

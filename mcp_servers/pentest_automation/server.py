import asyncio
import ipaddress
import json
import time
from datetime import datetime
from collections import deque

import structlog

from mcp_servers.common.base_server import BaseMCPServer
from mcp_servers.common.schemas import ToolResult
from mcp_servers.pentest_automation.actions.port_verify import PortVerifyAction
from mcp_servers.pentest_automation.actions.http_headers import HTTPHeadersAction
from mcp_servers.pentest_automation.actions.tls_check import TLSCheckAction
from mcp_servers.pentest_automation.actions.ssh_hardening import SSHHardeningAction
from mcp_servers.pentest_automation.actions.upnp_check import UPnPCheckAction
from mcp_servers.pentest_automation.actions.admin_exposure import AdminExposureAction
from mcp_servers.pentest_automation.actions.waf_detection import WAFDetectionAction
from mcp_servers.pentest_automation.actions.web_vuln_scan import WebVulnScanAction
from mcp_servers.pentest_automation.actions.service_fingerprint import ServiceFingerprintAction
from mcp_servers.pentest_automation.actions.dns_recon import DNSReconAction
from mcp_servers.pentest_automation.actions.default_creds import DefaultCredsAction
from mcp_servers.pentest_automation.actions.network_recon import NetworkReconAction

logger = structlog.get_logger()

server = BaseMCPServer(name="pentest-automation", version="1.0.0")

# ---------------------------------------------------------------------------
# Scope validator: only allow RFC 1918 private IP ranges
# ---------------------------------------------------------------------------
RFC1918_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]


def _validate_scope(target: str) -> tuple[bool, str]:
    """Check whether *target* falls within the allowed RFC 1918 ranges.

    Returns a tuple of (is_valid, message).
    """
    try:
        addr = ipaddress.ip_address(target.strip())
    except ValueError:
        return False, f"'{target}' is not a valid IP address."

    if any(addr in net for net in RFC1918_NETWORKS):
        return True, f"{target} is within allowed scope."
    return False, f"{target} is NOT within allowed RFC 1918 scope."


# ---------------------------------------------------------------------------
# Rate limiter: max 10 actions per minute (sliding window)
# ---------------------------------------------------------------------------
_ACTION_TIMESTAMPS: deque[float] = deque()
_RATE_LIMIT = 10          # max actions
_RATE_WINDOW = 60.0       # window in seconds


def _check_rate_limit() -> tuple[bool, str]:
    """Return (allowed, message). Prunes expired entries first."""
    now = time.monotonic()
    while _ACTION_TIMESTAMPS and (now - _ACTION_TIMESTAMPS[0]) > _RATE_WINDOW:
        _ACTION_TIMESTAMPS.popleft()

    if len(_ACTION_TIMESTAMPS) >= _RATE_LIMIT:
        oldest = _ACTION_TIMESTAMPS[0]
        wait = _RATE_WINDOW - (now - oldest)
        return False, f"Rate limit exceeded ({_RATE_LIMIT} actions/min). Try again in {wait:.1f}s."

    _ACTION_TIMESTAMPS.append(now)
    return True, "OK"


# ---------------------------------------------------------------------------
# Registry of available pentest actions
# ---------------------------------------------------------------------------
ACTION_REGISTRY: dict[str, dict] = {
    "port_verify": {
        "class": PortVerifyAction,
        "description": "Verify specific TCP ports are open using async connect probes.",
        "risk_level": "low",
        "params": {
            "ports": {
                "type": "list[int]",
                "required": False,
                "description": "List of ports to check. Default: top 20 common ports.",
            },
        },
    },
    "http_headers": {
        "class": HTTPHeadersAction,
        "description": "Check HTTP security headers and probe for exposed admin paths.",
        "risk_level": "low",
        "params": {
            "port": {
                "type": "int",
                "required": False,
                "description": "HTTP port. Default: 80.",
            },
            "use_tls": {
                "type": "bool",
                "required": False,
                "description": "Use HTTPS. Default: false.",
            },
        },
    },
    "tls_check": {
        "class": TLSCheckAction,
        "description": "Analyze TLS version, cipher suites, and certificate validity.",
        "risk_level": "low",
        "params": {
            "port": {
                "type": "int",
                "required": False,
                "description": "TLS port. Default: 443.",
            },
        },
    },
    "ssh_hardening": {
        "class": SSHHardeningAction,
        "description": "Analyze SSH banner, key exchange, auth methods, and root login config.",
        "risk_level": "low",
        "params": {
            "port": {
                "type": "int",
                "required": False,
                "description": "SSH port. Default: 22.",
            },
        },
    },
    "upnp_check": {
        "class": UPnPCheckAction,
        "description": "Detect UPnP/SSDP services and check for port-forwarding exposure.",
        "risk_level": "low",
        "params": {},
    },
    "admin_exposure": {
        "class": AdminExposureAction,
        "description": "Detect exposed admin interfaces, login pages, and default credential indicators.",
        "risk_level": "medium",
        "params": {
            "ports": {
                "type": "list[int]",
                "required": False,
                "description": "Ports to check. Default: [80, 443, 8080, 8443, 9090].",
            },
        },
    },
    # ── NeuroSploit-inspired advanced actions ──────────────────────────
    "waf_detection": {
        "class": WAFDetectionAction,
        "description": "Detect and fingerprint Web Application Firewalls using 16 WAF signatures.",
        "risk_level": "medium",
        "category": "neurosploit",
        "params": {
            "port": {
                "type": "int",
                "required": False,
                "description": "HTTP port. Default: 80.",
            },
            "use_tls": {
                "type": "bool",
                "required": False,
                "description": "Use HTTPS. Default: false.",
            },
        },
    },
    "web_vuln_scan": {
        "class": WebVulnScanAction,
        "description": "Test for SQLi, XSS, LFI, Command Injection, SSRF, Open Redirects.",
        "risk_level": "high",
        "category": "neurosploit",
        "params": {
            "port": {
                "type": "int",
                "required": False,
                "description": "HTTP port. Default: 80.",
            },
            "use_tls": {
                "type": "bool",
                "required": False,
                "description": "Use HTTPS. Default: false.",
            },
        },
    },
    "service_fingerprint": {
        "class": ServiceFingerprintAction,
        "description": "Deep service/version detection via banner grabbing across 15 service types.",
        "risk_level": "low",
        "category": "neurosploit",
        "params": {
            "ports": {
                "type": "list[int]",
                "required": False,
                "description": "Ports to probe. Default: 15 common service ports.",
            },
        },
    },
    "dns_recon": {
        "class": DNSReconAction,
        "description": "Reverse DNS, PTR lookups, and local hostname discovery.",
        "risk_level": "low",
        "category": "neurosploit",
        "params": {},
    },
    "default_creds": {
        "class": DefaultCredsAction,
        "description": "Test for default/factory credentials on web interfaces and FTP.",
        "risk_level": "high",
        "category": "neurosploit",
        "params": {
            "ports": {
                "type": "list[int]",
                "required": False,
                "description": "HTTP ports to check. Default: [80, 8080, 8443, 443, 9090].",
            },
        },
    },
    "network_recon": {
        "class": NetworkReconAction,
        "description": "Extended port scan, OS hints via TTL, and service mapping with device profiling.",
        "risk_level": "low",
        "category": "neurosploit",
        "params": {
            "scan_neighbors": {
                "type": "bool",
                "required": False,
                "description": "Also scan neighboring IPs. Default: false.",
            },
        },
    },
}


# ---------------------------------------------------------------------------
# Tool: list_actions
# ---------------------------------------------------------------------------
@server.tool(
    name="list_actions",
    description="Returns the list of all available pentest actions with descriptions and risk levels.",
    input_schema={
        "type": "object",
        "properties": {},
        "required": [],
    },
)
async def list_actions() -> dict:
    actions = []
    for action_id, info in ACTION_REGISTRY.items():
        actions.append({
            "action_id": action_id,
            "name": info["class"].name,
            "description": info["description"],
            "risk_level": info["risk_level"],
            "params": info["params"],
        })

    return ToolResult(
        success=True,
        data={"actions": actions, "count": len(actions)},
        metadata={
            "rate_limit": f"{_RATE_LIMIT} actions per {int(_RATE_WINDOW)}s",
            "allowed_scope": "RFC 1918 (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8)",
        },
    ).model_dump()


# ---------------------------------------------------------------------------
# Tool: verify_scope
# ---------------------------------------------------------------------------
@server.tool(
    name="verify_scope",
    description="Check if a target IP is within allowed scope (RFC 1918 private ranges).",
    input_schema={
        "type": "object",
        "properties": {
            "target": {
                "type": "string",
                "description": "Target IP address to validate.",
            },
        },
        "required": ["target"],
    },
)
async def verify_scope(target: str) -> dict:
    is_valid, message = _validate_scope(target)

    data = {
        "target": target,
        "in_scope": is_valid,
        "message": message,
        "allowed_ranges": [
            "10.0.0.0/8",
            "172.16.0.0/12",
            "192.168.0.0/16",
            "127.0.0.0/8",
        ],
    }

    return ToolResult(
        success=True,
        data=data,
        metadata={"target": target, "in_scope": is_valid},
    ).model_dump()


# ---------------------------------------------------------------------------
# Tool: execute_action
# ---------------------------------------------------------------------------
@server.tool(
    name="execute_action",
    description=(
        "Execute a predefined pentest action against a target. "
        "Validates scope (RFC 1918 only) and rate limits (max 10/min) before running. "
        "Returns structured findings."
    ),
    input_schema={
        "type": "object",
        "properties": {
            "action_id": {
                "type": "string",
                "description": "ID of the pentest action to execute.",
                "enum": list(ACTION_REGISTRY.keys()),
            },
            "target": {
                "type": "string",
                "description": "Target IP address (must be RFC 1918).",
            },
            "params": {
                "type": "object",
                "description": "Optional parameters specific to the action.",
                "default": {},
            },
        },
        "required": ["action_id", "target"],
    },
)
async def execute_action(action_id: str, target: str, params: dict | None = None) -> dict:
    params = params or {}

    # 1. Validate action exists
    if action_id not in ACTION_REGISTRY:
        return ToolResult(
            success=False,
            error=f"Unknown action_id '{action_id}'. Use list_actions to see available actions.",
        ).model_dump()

    # 2. Validate scope
    in_scope, scope_msg = _validate_scope(target)
    if not in_scope:
        logger.warning("Scope validation failed", target=target, action=action_id, reason=scope_msg)
        return ToolResult(
            success=False,
            error=f"Scope validation failed: {scope_msg}",
            data={"target": target, "in_scope": False},
        ).model_dump()

    # 3. Check rate limit
    allowed, rate_msg = _check_rate_limit()
    if not allowed:
        logger.warning("Rate limit hit", action=action_id, target=target)
        return ToolResult(
            success=False,
            error=f"Rate limit: {rate_msg}",
        ).model_dump()

    # 4. Instantiate and execute the action
    action_info = ACTION_REGISTRY[action_id]
    action_cls = action_info["class"]
    action_instance = action_cls()

    logger.info(
        "Executing pentest action",
        action_id=action_id,
        target=target,
        params=params,
    )

    start = time.monotonic()
    try:
        findings = await action_instance.execute(target=target, **params)
    except TypeError as e:
        return ToolResult(
            success=False,
            error=f"Invalid parameters for action '{action_id}': {str(e)}",
        ).model_dump()
    except Exception as e:
        logger.error("Action execution failed", action_id=action_id, target=target, error=str(e))
        return ToolResult(
            success=False,
            error=f"Action '{action_id}' failed: {str(e)}",
        ).model_dump()

    elapsed = time.monotonic() - start

    logger.info(
        "Pentest action complete",
        action_id=action_id,
        target=target,
        finding_count=len(findings),
        elapsed_s=round(elapsed, 2),
    )

    return ToolResult(
        success=True,
        data={
            "action_id": action_id,
            "target": target,
            "findings": findings,
        },
        artifacts=[{
            "type": "raw_output",
            "tool": f"pentest_{action_id}",
            "target": target,
            "content": json.dumps(findings, indent=2),
            "timestamp": datetime.utcnow().isoformat(),
        }],
        metadata={
            "finding_count": len(findings),
            "elapsed_seconds": round(elapsed, 2),
            "action_id": action_id,
            "risk_level": action_info["risk_level"],
        },
    ).model_dump()


if __name__ == "__main__":
    asyncio.run(server.run_stdio())

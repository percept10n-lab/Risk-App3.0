"""Exploit/Exposure Intel MCP Server.

Enriches vulnerability findings with CVE/CWE/CPE data, calculates
transparent exploitability scores, and checks threat-intelligence feeds
(CISA KEV, EPSS).  All data is built-in and works fully offline.
"""

import asyncio
import json
from datetime import datetime
from typing import Any

import structlog

from mcp_servers.common.base_server import BaseMCPServer
from mcp_servers.common.schemas import ToolResult
from mcp_servers.exploit_exposure.enrichment import FindingEnricher
from mcp_servers.exploit_exposure.scoring import ExploitabilityScorer
from mcp_servers.exploit_exposure.feeds import ThreatFeedCache

logger = structlog.get_logger()

server = BaseMCPServer(name="exploit-exposure", version="1.0.0")
enricher = FindingEnricher()
scorer = ExploitabilityScorer()
feed_cache = ThreatFeedCache()


# ---------------------------------------------------------------------------
# Tool 1: enrich_finding
# ---------------------------------------------------------------------------
@server.tool(
    name="enrich_finding",
    description=(
        "Enrich a vulnerability finding with CVE details (NVD), CWE hierarchy "
        "and description, CPE matching, CISA KEV status, and EPSS scores. "
        "Returns the original finding augmented with all available intelligence."
    ),
    input_schema={
        "type": "object",
        "properties": {
            "finding": {
                "type": "object",
                "description": (
                    "Finding to enrich. Keys: title (str, required), "
                    "cve_ids (list[str]), cwe_id (str), cpe (str), severity (str)"
                ),
                "properties": {
                    "title": {"type": "string"},
                    "cve_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "CVE identifiers (e.g. CVE-2021-44228)",
                    },
                    "cwe_id": {
                        "type": "string",
                        "description": "CWE identifier (e.g. CWE-79)",
                    },
                    "cpe": {
                        "type": "string",
                        "description": "CPE string (e.g. cpe:2.3:a:apache:http_server:2.4.49:*:*:*:*:*:*:*)",
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["info", "low", "medium", "high", "critical"],
                    },
                },
                "required": ["title"],
            },
        },
        "required": ["finding"],
    },
)
async def enrich_finding(finding: dict) -> dict:
    """Enrich a single finding with all available exploit/exposure intel."""
    try:
        enriched = enricher.enrich(finding)
        return ToolResult(
            success=True,
            data=enriched,
            artifacts=[{
                "type": "raw_output",
                "tool": "enrich_finding",
                "target": finding.get("title", "unknown"),
                "content": json.dumps(enriched, indent=2, default=str),
                "timestamp": datetime.utcnow().isoformat(),
            }],
            metadata={
                "title": finding.get("title"),
                "cve_count": len(finding.get("cve_ids") or []),
                "kev_hits": len(enriched.get("kev_status", [])),
                "epss_hits": len(enriched.get("epss_scores", [])),
            },
        ).model_dump()
    except Exception as exc:
        logger.error("enrich_finding failed", error=str(exc), finding=finding)
        return ToolResult(
            success=False,
            error=f"Enrichment failed: {exc}",
        ).model_dump()


# ---------------------------------------------------------------------------
# Tool 2: calculate_exploitability
# ---------------------------------------------------------------------------
@server.tool(
    name="calculate_exploitability",
    description=(
        "Calculate a transparent exploitability score (0-10) for a finding "
        "in the context of a specific asset. Returns the score, a list of "
        "human-readable rationale strings, and individual factor breakdowns. "
        "No black-box calculations -- every point is explained."
    ),
    input_schema={
        "type": "object",
        "properties": {
            "finding": {
                "type": "object",
                "description": (
                    "Finding data. Keys: title, severity, cve_ids, cwe_id, "
                    "auth_required (bool), attack_complexity (low/high)"
                ),
                "properties": {
                    "title": {"type": "string"},
                    "severity": {
                        "type": "string",
                        "enum": ["info", "low", "medium", "high", "critical"],
                    },
                    "cve_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                    },
                    "cwe_id": {"type": "string"},
                    "auth_required": {
                        "type": "boolean",
                        "description": "Whether authentication is required to exploit",
                    },
                    "attack_complexity": {
                        "type": "string",
                        "enum": ["low", "high"],
                        "description": "Attack complexity level",
                    },
                },
                "required": ["title", "severity"],
            },
            "asset": {
                "type": "object",
                "description": (
                    "Asset context. Keys: ip_address, exposure (wan/lan/dmz), "
                    "zone (lan/iot/guest/dmz), criticality (critical/high/medium/low)"
                ),
                "properties": {
                    "ip_address": {"type": "string"},
                    "exposure": {
                        "type": "string",
                        "description": "Network exposure level (wan, lan, dmz, internal, public)",
                    },
                    "zone": {
                        "type": "string",
                        "description": "Network zone (lan, iot, guest, dmz, untrusted)",
                    },
                    "criticality": {
                        "type": "string",
                        "enum": ["critical", "high", "medium", "low"],
                    },
                },
            },
        },
        "required": ["finding", "asset"],
    },
)
async def calculate_exploitability(finding: dict, asset: dict) -> dict:
    """Calculate exploitability score with full transparency."""
    try:
        result = scorer.calculate(finding, asset)
        return ToolResult(
            success=True,
            data=result,
            artifacts=[{
                "type": "raw_output",
                "tool": "calculate_exploitability",
                "target": finding.get("title", "unknown"),
                "content": json.dumps(result, indent=2, default=str),
                "timestamp": datetime.utcnow().isoformat(),
            }],
            metadata={
                "score": result["score"],
                "factor_count": len(result["factors"]),
                "finding_title": finding.get("title"),
                "asset_ip": asset.get("ip_address"),
            },
        ).model_dump()
    except Exception as exc:
        logger.error("calculate_exploitability failed", error=str(exc))
        return ToolResult(
            success=False,
            error=f"Scoring failed: {exc}",
        ).model_dump()


# ---------------------------------------------------------------------------
# Tool 3: check_kev
# ---------------------------------------------------------------------------
@server.tool(
    name="check_kev",
    description=(
        "Check if one or more CVEs appear in the CISA Known Exploited "
        "Vulnerabilities (KEV) catalog. Uses a built-in offline snapshot "
        "of notable KEV entries relevant to home networks and common services."
    ),
    input_schema={
        "type": "object",
        "properties": {
            "cve_ids": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of CVE identifiers to check (e.g. ['CVE-2021-44228'])",
            },
        },
        "required": ["cve_ids"],
    },
)
async def check_kev(cve_ids: list[str]) -> dict:
    """Check CVEs against the CISA KEV catalog."""
    try:
        results: dict[str, Any] = {}
        kev_hits: list[str] = []

        for cve_id in cve_ids:
            status = feed_cache.get_kev_status(cve_id)
            if status:
                results[cve_id] = status
                kev_hits.append(cve_id)
            else:
                results[cve_id] = {"cve_id": cve_id, "in_kev": False}

        summary = {
            "total_checked": len(cve_ids),
            "kev_hits": len(kev_hits),
            "kev_cves": kev_hits,
        }

        return ToolResult(
            success=True,
            data={"results": results, "summary": summary},
            artifacts=[{
                "type": "raw_output",
                "tool": "check_kev",
                "target": ", ".join(cve_ids[:5]) + ("..." if len(cve_ids) > 5 else ""),
                "content": json.dumps({"results": results, "summary": summary}, indent=2),
                "timestamp": datetime.utcnow().isoformat(),
            }],
            metadata={"total_checked": len(cve_ids), "kev_hits": len(kev_hits)},
        ).model_dump()
    except Exception as exc:
        logger.error("check_kev failed", error=str(exc))
        return ToolResult(
            success=False,
            error=f"KEV check failed: {exc}",
        ).model_dump()


# ---------------------------------------------------------------------------
# Tool 4: get_epss_score
# ---------------------------------------------------------------------------
@server.tool(
    name="get_epss_score",
    description=(
        "Retrieve EPSS (Exploit Prediction Scoring System) scores for one or "
        "more CVEs. Returns the probability (0-1) that each CVE will be "
        "exploited in the next 30 days, plus the percentile ranking. Uses a "
        "built-in offline snapshot."
    ),
    input_schema={
        "type": "object",
        "properties": {
            "cve_ids": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of CVE identifiers (e.g. ['CVE-2021-44228', 'CVE-2024-6387'])",
            },
        },
        "required": ["cve_ids"],
    },
)
async def get_epss_score(cve_ids: list[str]) -> dict:
    """Get EPSS scores for the provided CVEs."""
    try:
        results: dict[str, Any] = {}
        found_count = 0

        for cve_id in cve_ids:
            epss = feed_cache.get_epss_score(cve_id)
            if epss:
                results[cve_id] = epss
                found_count += 1
            else:
                results[cve_id] = {
                    "cve_id": cve_id,
                    "epss_score": None,
                    "percentile": None,
                    "note": "Not available in local EPSS snapshot.",
                }

        summary = {
            "total_checked": len(cve_ids),
            "scores_found": found_count,
            "scores_missing": len(cve_ids) - found_count,
        }

        return ToolResult(
            success=True,
            data={"results": results, "summary": summary},
            artifacts=[{
                "type": "raw_output",
                "tool": "get_epss_score",
                "target": ", ".join(cve_ids[:5]) + ("..." if len(cve_ids) > 5 else ""),
                "content": json.dumps({"results": results, "summary": summary}, indent=2),
                "timestamp": datetime.utcnow().isoformat(),
            }],
            metadata={"total_checked": len(cve_ids), "scores_found": found_count},
        ).model_dump()
    except Exception as exc:
        logger.error("get_epss_score failed", error=str(exc))
        return ToolResult(
            success=False,
            error=f"EPSS lookup failed: {exc}",
        ).model_dump()


if __name__ == "__main__":
    asyncio.run(server.run_stdio())

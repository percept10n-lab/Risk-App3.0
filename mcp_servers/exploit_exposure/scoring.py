"""Transparent exploitability scoring engine.

Calculates an exploitability score (0-10) for a finding in the context of a
specific asset.  Every factor is individually documented so the result is
fully auditable -- no black-box calculations.
"""

from __future__ import annotations

from typing import Any

import structlog

from mcp_servers.exploit_exposure.enrichment import CWE_CATALOG
from mcp_servers.exploit_exposure.feeds import ThreatFeedCache

logger = structlog.get_logger()

# Severity label -> base score mapping
_SEVERITY_BASE: dict[str, float] = {
    "info": 0.0,
    "low": 2.0,
    "medium": 4.0,
    "high": 7.0,
    "critical": 9.0,
}

# Asset criticality label -> additional score
_CRITICALITY_SCORE: dict[str, float] = {
    "critical": 1.0,
    "high": 0.7,
    "medium": 0.3,
    "low": 0.0,
}


class ExploitabilityScorer:
    """Calculate a transparent, factor-based exploitability score.

    The scorer examines a *finding* (vulnerability / misconfiguration)
    together with an *asset* context and produces a 0-10 score with a
    full explanation of every contributing factor.
    """

    def __init__(self) -> None:
        self._feed_cache = ThreatFeedCache()
        self._cwe_catalog: dict[str, dict[str, Any]] = CWE_CATALOG
        logger.info("ExploitabilityScorer initialised")

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def calculate(self, finding: dict, asset: dict) -> dict:
        """Calculate exploitability for *finding* in the context of *asset*.

        Parameters
        ----------
        finding : dict
            Keys: ``severity``, ``cve_ids``, ``cwe_id``,
            ``auth_required`` (bool), ``attack_complexity`` (str: low/high).
        asset : dict
            Keys: ``exposure`` (str: wan/lan/internal), ``zone`` (str),
            ``criticality`` (str: critical/high/medium/low).

        Returns
        -------
        dict
            ``score`` (float 0-10), ``rationale`` (list[str]),
            ``factors`` (dict of individual scores).
        """
        factors: dict[str, float] = {}
        rationale: list[str] = []

        # -- 1. Base severity --
        severity = (finding.get("severity") or "info").lower()
        base = _SEVERITY_BASE.get(severity, 0.0)
        factors["base_severity"] = base
        rationale.append(
            f"Base severity '{severity}' contributes {base:.1f} points."
        )

        # -- 2. Exposure factor --
        exposure_val = self._calc_exposure(asset)
        factors["exposure_factor"] = exposure_val
        if exposure_val > 0:
            rationale.append(
                f"Exposure factor adds {exposure_val:+.1f} "
                f"(exposure={asset.get('exposure', 'unknown')}, zone={asset.get('zone', 'unknown')})."
            )

        # -- 3. Exploit availability (CVE/KEV/EPSS) --
        exploit_val, exploit_notes = self._calc_exploit_availability(finding)
        factors["exploit_availability"] = exploit_val
        for note in exploit_notes:
            rationale.append(note)

        # -- 4. Authentication required --
        auth_val = self._calc_auth_factor(finding)
        factors["authentication_required"] = auth_val
        if auth_val != 0:
            rationale.append(
                f"Authentication factor: {auth_val:+.1f} "
                f"({'no auth needed' if auth_val > 0 else 'auth required'})."
            )

        # -- 5. Attack complexity --
        complexity_val = self._calc_complexity(finding)
        factors["attack_complexity"] = complexity_val
        if complexity_val != 0:
            rationale.append(
                f"Attack complexity factor: {complexity_val:+.1f} "
                f"({'low complexity' if complexity_val > 0 else 'high complexity'})."
            )

        # -- 6. CWE severity boost --
        cwe_val = self._calc_cwe_severity(finding)
        factors["cwe_severity"] = cwe_val
        if cwe_val > 0:
            cwe_id = finding.get("cwe_id", "unknown")
            cwe_entry = self._cwe_catalog.get(
                cwe_id if cwe_id.startswith("CWE-") else f"CWE-{cwe_id}", {}
            )
            rationale.append(
                f"CWE severity boost: +{cwe_val:.1f} "
                f"(CWE class: {cwe_entry.get('name', cwe_id)})."
            )

        # -- 7. CVSS base score from cvefeed.io (if available) --
        cvss_val = self._calc_cvss_score(finding)
        factors["cvss_score"] = cvss_val
        if cvss_val > 0:
            rationale.append(
                f"CVSS v3.1 base score contributes +{cvss_val:.1f} (weighted 30%)."
            )

        # -- 8. Asset criticality --
        crit_val = self._calc_asset_criticality(asset)
        factors["asset_criticality"] = crit_val
        if crit_val > 0:
            rationale.append(
                f"Asset criticality '{asset.get('criticality', 'unknown')}' adds +{crit_val:.1f}."
            )

        # -- Final score (clamped 0-10) --
        raw_score = sum(factors.values())
        final_score = max(0.0, min(10.0, raw_score))
        factors["raw_total"] = raw_score

        if raw_score != final_score:
            rationale.append(
                f"Raw total {raw_score:.1f} clamped to [{0.0}, {10.0}] -> {final_score:.1f}."
            )

        rationale.append(f"Final exploitability score: {final_score:.1f}/10.0.")

        result = {
            "score": round(final_score, 2),
            "rationale": rationale,
            "factors": {k: round(v, 2) for k, v in factors.items()},
        }

        logger.info(
            "Exploitability score calculated",
            finding_title=finding.get("title", "unknown"),
            score=final_score,
            factor_count=len(factors),
        )
        return result

    # ------------------------------------------------------------------
    # Factor calculations
    # ------------------------------------------------------------------

    @staticmethod
    def _calc_exposure(asset: dict) -> float:
        """Calculate exposure factor (+0 to +2)."""
        score = 0.0
        exposure = (asset.get("exposure") or "").lower()
        zone = (asset.get("zone") or "").lower()

        # WAN / internet exposed
        if exposure in ("wan", "internet", "external", "public"):
            score += 2.0
        elif exposure in ("dmz",):
            score += 1.5
        elif exposure in ("lan", "internal"):
            score += 0.0

        # Untrusted zone adjustment
        if zone in ("guest", "iot", "untrusted", "dmz"):
            score += 0.5

        return min(score, 2.0)

    def _calc_exploit_availability(self, finding: dict) -> tuple[float, list[str]]:
        """Calculate exploit-availability factor (+0 to +2)."""
        score = 0.0
        notes: list[str] = []
        cve_ids: list[str] = finding.get("cve_ids") or []

        if not cve_ids:
            notes.append("No CVE IDs; exploit availability unknown (+0.0).")
            return score, notes

        has_kev = False
        has_high_epss = False
        max_epss = 0.0

        for cve_id in cve_ids:
            kev = self._feed_cache.get_kev_status(cve_id)
            if kev:
                has_kev = True
            epss = self._feed_cache.get_epss_score(cve_id)
            if epss and epss["epss_score"] > max_epss:
                max_epss = epss["epss_score"]

        # Known CVE with high EPSS -> public exploit likely
        if max_epss >= 0.7:
            score += 2.0
            has_high_epss = True
            notes.append(
                f"High EPSS score ({max_epss:.3f}) indicates public exploit availability (+2.0)."
            )
        elif max_epss >= 0.3:
            score += 1.0
            has_high_epss = True
            notes.append(
                f"Moderate EPSS score ({max_epss:.3f}) suggests exploit may exist (+1.0)."
            )
        elif cve_ids:
            score += 0.5
            notes.append(
                f"Known CVE(s) present but EPSS score is low/unknown (+0.5)."
            )

        # KEV bonus (on top of EPSS)
        if has_kev:
            kev_bonus = 1.0 if not has_high_epss else 0.5
            score += kev_bonus
            notes.append(
                f"CVE(s) in CISA KEV (actively exploited in the wild) (+{kev_bonus:.1f})."
            )

        # Clamp to [0, 2]
        score = min(score, 2.0)
        return score, notes

    @staticmethod
    def _calc_auth_factor(finding: dict) -> float:
        """Authentication factor (-1 to +1)."""
        auth_required = finding.get("auth_required")
        if auth_required is True:
            return -1.0
        elif auth_required is False:
            return 1.0
        # Unknown / not specified -> neutral
        return 0.0

    @staticmethod
    def _calc_complexity(finding: dict) -> float:
        """Attack complexity factor (-1 to +1)."""
        complexity = (finding.get("attack_complexity") or "").lower()
        if complexity == "low":
            return 1.0
        elif complexity == "high":
            return -1.0
        return 0.0

    def _calc_cwe_severity(self, finding: dict) -> float:
        """CWE-based severity boost (0 to +1)."""
        cwe_id = finding.get("cwe_id")
        if not cwe_id:
            return 0.0
        cwe_key = cwe_id.strip().upper()
        if not cwe_key.startswith("CWE-"):
            cwe_key = f"CWE-{cwe_key}"
        entry = self._cwe_catalog.get(cwe_key)
        if entry:
            return min(entry.get("severity_boost", 0.0), 1.0)
        return 0.0

    @staticmethod
    def _calc_cvss_score(finding: dict) -> float:
        """CVSS v3.1 base score factor (0 to +1), weighted at 30%."""
        cvss_score = finding.get("nvd_cvss_score") or finding.get("cvss_score")
        if cvss_score is None:
            return 0.0
        # Normalize 0-10 CVSS to 0-1 contribution, weighted at 30%
        return min(1.0, (cvss_score / 10.0) * 0.3 * 10)

    @staticmethod
    def _calc_asset_criticality(asset: dict) -> float:
        """Asset criticality bonus (0 to +1)."""
        criticality = (asset.get("criticality") or "medium").lower()
        return _CRITICALITY_SCORE.get(criticality, 0.0)

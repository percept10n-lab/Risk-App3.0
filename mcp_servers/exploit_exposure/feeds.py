"""Threat feed caches for CISA KEV and EPSS data.

Provides built-in snapshots as offline fallback, with optional live fetching
from CISA KEV, FIRST EPSS, and cvefeed.io APIs.
"""

from __future__ import annotations

import asyncio
import time
from typing import Any

import httpx
import structlog

logger = structlog.get_logger()

# CVE lookup concurrency limiter
_cve_semaphore = asyncio.Semaphore(5)

# ---------------------------------------------------------------------------
# CISA Known Exploited Vulnerabilities (KEV) -- built-in snapshot
# Focused on CVEs relevant to home networks, routers, IoT, and common
# services (OpenSSH, Apache, nginx, DNS, NTP, etc.)
# ---------------------------------------------------------------------------
_KEV_CATALOG: list[dict[str, str]] = [
    # -- Router / Firewall --
    {
        "cve_id": "CVE-2018-13379",
        "vendor": "Fortinet",
        "product": "FortiOS",
        "description": "FortiOS SSL VPN path traversal allows unauthenticated file read (credentials).",
        "date_added": "2021-11-03",
        "required_action": "Upgrade FortiOS to a patched version; reset all VPN credentials.",
    },
    {
        "cve_id": "CVE-2019-1653",
        "vendor": "Cisco",
        "product": "RV320/RV325 Routers",
        "description": "Information disclosure via unauthenticated access to configuration.",
        "date_added": "2021-11-03",
        "required_action": "Apply firmware update from Cisco.",
    },
    {
        "cve_id": "CVE-2019-19781",
        "vendor": "Citrix",
        "product": "ADC / Gateway",
        "description": "Directory traversal leading to remote code execution.",
        "date_added": "2021-11-03",
        "required_action": "Apply Citrix-provided patches immediately.",
    },
    {
        "cve_id": "CVE-2020-5902",
        "vendor": "F5",
        "product": "BIG-IP",
        "description": "TMUI remote code execution vulnerability.",
        "date_added": "2021-11-03",
        "required_action": "Apply F5 hotfix or upgrade BIG-IP.",
    },
    {
        "cve_id": "CVE-2021-20090",
        "vendor": "Buffalo / Arcadyan",
        "product": "Various home routers",
        "description": "Authentication bypass in Arcadyan-based router firmware.",
        "date_added": "2021-11-03",
        "required_action": "Update router firmware to latest version.",
    },
    {
        "cve_id": "CVE-2017-17215",
        "vendor": "Huawei",
        "product": "HG532 Router",
        "description": "Remote code execution via crafted packets to UPnP service.",
        "date_added": "2021-11-03",
        "required_action": "Disable UPnP and update firmware.",
    },
    {
        "cve_id": "CVE-2023-20198",
        "vendor": "Cisco",
        "product": "IOS XE",
        "description": "Privilege escalation via web UI allows creation of admin account.",
        "date_added": "2023-10-16",
        "required_action": "Disable HTTP/HTTPS Server feature; apply Cisco patches.",
    },
    {
        "cve_id": "CVE-2024-3400",
        "vendor": "Palo Alto Networks",
        "product": "PAN-OS GlobalProtect",
        "description": "Command injection in GlobalProtect gateway allows unauthenticated RCE.",
        "date_added": "2024-04-12",
        "required_action": "Apply PAN-OS hotfix; enable Threat Prevention signatures.",
    },
    # -- IoT / Smart Home --
    {
        "cve_id": "CVE-2021-35394",
        "vendor": "Realtek",
        "product": "Realtek Jungle SDK",
        "description": "Multiple buffer overflows in UDPServer; used by many IoT devices.",
        "date_added": "2023-09-18",
        "required_action": "Contact device vendor for firmware update.",
    },
    {
        "cve_id": "CVE-2022-27255",
        "vendor": "Realtek",
        "product": "eCos RSDK",
        "description": "Remote buffer overflow in SIP ALG module affecting many routers.",
        "date_added": "2023-09-18",
        "required_action": "Update device firmware; disable SIP ALG if possible.",
    },
    {
        "cve_id": "CVE-2021-36260",
        "vendor": "Hikvision",
        "product": "IP Cameras",
        "description": "Command injection via crafted HTTP requests to IP cameras.",
        "date_added": "2022-01-10",
        "required_action": "Update camera firmware; restrict network access.",
    },
    {
        "cve_id": "CVE-2018-10561",
        "vendor": "Dasan / GPON",
        "product": "GPON Home Routers",
        "description": "Authentication bypass on GPON home routers.",
        "date_added": "2021-11-03",
        "required_action": "Replace or update affected GPON equipment.",
    },
    # -- OpenSSH --
    {
        "cve_id": "CVE-2023-38408",
        "vendor": "OpenBSD",
        "product": "OpenSSH",
        "description": "Remote code execution via ssh-agent forwarding with PKCS#11 providers.",
        "date_added": "2023-07-20",
        "required_action": "Upgrade to OpenSSH 9.3p2 or later.",
    },
    {
        "cve_id": "CVE-2024-6387",
        "vendor": "OpenBSD",
        "product": "OpenSSH",
        "description": "RegreSSHion: signal handler race condition allows unauthenticated RCE on glibc-based systems.",
        "date_added": "2024-07-01",
        "required_action": "Upgrade to OpenSSH 9.8p1 or later.",
    },
    {
        "cve_id": "CVE-2016-20012",
        "vendor": "OpenBSD",
        "product": "OpenSSH",
        "description": "User enumeration via timing side channel.",
        "date_added": "2021-11-03",
        "required_action": "Upgrade OpenSSH; implement fail2ban or rate limiting.",
    },
    # -- Apache HTTP Server --
    {
        "cve_id": "CVE-2021-41773",
        "vendor": "Apache",
        "product": "HTTP Server",
        "description": "Path traversal and remote code execution in Apache 2.4.49.",
        "date_added": "2021-11-03",
        "required_action": "Upgrade to Apache HTTP Server 2.4.51 or later.",
    },
    {
        "cve_id": "CVE-2021-42013",
        "vendor": "Apache",
        "product": "HTTP Server",
        "description": "Path traversal fix bypass in Apache 2.4.50.",
        "date_added": "2021-11-03",
        "required_action": "Upgrade to Apache HTTP Server 2.4.51 or later.",
    },
    {
        "cve_id": "CVE-2023-25690",
        "vendor": "Apache",
        "product": "HTTP Server",
        "description": "HTTP request smuggling via mod_proxy when RewriteRule and ProxyPassMatch are used.",
        "date_added": "2023-03-14",
        "required_action": "Upgrade to Apache HTTP Server 2.4.56 or later.",
    },
    # -- nginx --
    {
        "cve_id": "CVE-2021-23017",
        "vendor": "F5 / nginx",
        "product": "nginx",
        "description": "DNS resolver off-by-one heap write allows RCE.",
        "date_added": "2021-11-03",
        "required_action": "Upgrade nginx to 1.20.1 / 1.21.0 or later.",
    },
    {
        "cve_id": "CVE-2022-41741",
        "vendor": "F5 / nginx",
        "product": "nginx",
        "description": "Memory corruption in mp4 module allows local code execution.",
        "date_added": "2022-10-19",
        "required_action": "Upgrade to nginx 1.23.2 / 1.22.1 or later.",
    },
    # -- DNS / NTP / Network Services --
    {
        "cve_id": "CVE-2020-1350",
        "vendor": "Microsoft",
        "product": "Windows DNS Server",
        "description": "SIGRed: wormable RCE in Windows DNS Server via crafted DNS response.",
        "date_added": "2021-11-03",
        "required_action": "Apply Microsoft security update.",
    },
    {
        "cve_id": "CVE-2023-44487",
        "vendor": "Multiple",
        "product": "HTTP/2 implementations",
        "description": "HTTP/2 Rapid Reset DDoS attack vector.",
        "date_added": "2023-10-10",
        "required_action": "Apply vendor patches; configure rate limiting.",
    },
    # -- Common services / Libraries --
    {
        "cve_id": "CVE-2021-44228",
        "vendor": "Apache",
        "product": "Log4j",
        "description": "Log4Shell: RCE via JNDI lookup in log messages.",
        "date_added": "2021-12-10",
        "required_action": "Upgrade to Log4j 2.17.1+; set LOG4J_FORMAT_MSG_NO_LOOKUPS=true.",
    },
    {
        "cve_id": "CVE-2022-22965",
        "vendor": "VMware / Spring",
        "product": "Spring Framework",
        "description": "Spring4Shell: RCE via data binding on JDK 9+.",
        "date_added": "2022-04-04",
        "required_action": "Upgrade to Spring Framework 5.3.18+ or 5.2.20+.",
    },
    {
        "cve_id": "CVE-2014-0160",
        "vendor": "OpenSSL",
        "product": "OpenSSL",
        "description": "Heartbleed: TLS heartbeat extension memory disclosure.",
        "date_added": "2021-11-03",
        "required_action": "Upgrade to OpenSSL 1.0.1g or later; revoke and reissue certificates.",
    },
    {
        "cve_id": "CVE-2014-6271",
        "vendor": "GNU",
        "product": "Bash",
        "description": "Shellshock: arbitrary code execution via crafted environment variables.",
        "date_added": "2021-11-03",
        "required_action": "Update Bash to a patched version.",
    },
    {
        "cve_id": "CVE-2017-5638",
        "vendor": "Apache",
        "product": "Struts 2",
        "description": "RCE via Content-Type header in multipart parser.",
        "date_added": "2021-11-03",
        "required_action": "Upgrade Apache Struts to 2.3.32 / 2.5.10.1+.",
    },
    {
        "cve_id": "CVE-2019-0708",
        "vendor": "Microsoft",
        "product": "Remote Desktop Services",
        "description": "BlueKeep: pre-auth RCE in RDP on older Windows versions.",
        "date_added": "2021-11-03",
        "required_action": "Apply Microsoft security update; disable RDP if not needed.",
    },
    {
        "cve_id": "CVE-2020-0601",
        "vendor": "Microsoft",
        "product": "Windows CryptoAPI",
        "description": "CurveBall: spoofing vulnerability in certificate validation.",
        "date_added": "2021-11-03",
        "required_action": "Apply Microsoft security update.",
    },
    {
        "cve_id": "CVE-2021-26855",
        "vendor": "Microsoft",
        "product": "Exchange Server",
        "description": "ProxyLogon: SSRF leading to RCE in Exchange Server.",
        "date_added": "2021-11-03",
        "required_action": "Apply Microsoft emergency patch for Exchange.",
    },
    {
        "cve_id": "CVE-2023-27997",
        "vendor": "Fortinet",
        "product": "FortiOS / FortiProxy",
        "description": "Heap-based buffer overflow in SSL-VPN pre-authentication.",
        "date_added": "2023-06-13",
        "required_action": "Upgrade to patched FortiOS version.",
    },
    {
        "cve_id": "CVE-2022-42475",
        "vendor": "Fortinet",
        "product": "FortiOS",
        "description": "Heap-based buffer overflow in sslvpnd allows unauthenticated RCE.",
        "date_added": "2022-12-13",
        "required_action": "Upgrade FortiOS immediately.",
    },
]

# Build a lookup dict keyed by CVE ID for O(1) access
_KEV_INDEX: dict[str, dict[str, str]] = {entry["cve_id"]: entry for entry in _KEV_CATALOG}

# ---------------------------------------------------------------------------
# EPSS-style scores -- synthetic offline snapshot
# Scores are modeled after real EPSS percentile data for the same CVEs.
# Each entry contains: cve_id, epss_score (probability 0-1), percentile (0-100).
# ---------------------------------------------------------------------------
_EPSS_DATA: dict[str, dict[str, Any]] = {
    "CVE-2018-13379": {"epss_score": 0.974, "percentile": 99.8},
    "CVE-2019-1653":  {"epss_score": 0.968, "percentile": 99.6},
    "CVE-2019-19781": {"epss_score": 0.975, "percentile": 99.9},
    "CVE-2020-5902":  {"epss_score": 0.974, "percentile": 99.8},
    "CVE-2021-20090": {"epss_score": 0.957, "percentile": 99.2},
    "CVE-2017-17215": {"epss_score": 0.962, "percentile": 99.3},
    "CVE-2023-20198": {"epss_score": 0.961, "percentile": 99.3},
    "CVE-2024-3400":  {"epss_score": 0.955, "percentile": 99.1},
    "CVE-2021-35394": {"epss_score": 0.967, "percentile": 99.5},
    "CVE-2022-27255": {"epss_score": 0.200, "percentile": 80.0},
    "CVE-2021-36260": {"epss_score": 0.971, "percentile": 99.7},
    "CVE-2018-10561": {"epss_score": 0.973, "percentile": 99.8},
    "CVE-2023-38408": {"epss_score": 0.150, "percentile": 73.0},
    "CVE-2024-6387":  {"epss_score": 0.350, "percentile": 88.0},
    "CVE-2016-20012": {"epss_score": 0.050, "percentile": 45.0},
    "CVE-2021-41773": {"epss_score": 0.975, "percentile": 99.9},
    "CVE-2021-42013": {"epss_score": 0.975, "percentile": 99.9},
    "CVE-2023-25690": {"epss_score": 0.420, "percentile": 90.0},
    "CVE-2021-23017": {"epss_score": 0.500, "percentile": 92.0},
    "CVE-2022-41741": {"epss_score": 0.120, "percentile": 68.0},
    "CVE-2020-1350":  {"epss_score": 0.850, "percentile": 98.0},
    "CVE-2023-44487": {"epss_score": 0.600, "percentile": 94.0},
    "CVE-2021-44228": {"epss_score": 0.976, "percentile": 99.9},
    "CVE-2022-22965": {"epss_score": 0.974, "percentile": 99.8},
    "CVE-2014-0160":  {"epss_score": 0.975, "percentile": 99.9},
    "CVE-2014-6271":  {"epss_score": 0.976, "percentile": 99.9},
    "CVE-2017-5638":  {"epss_score": 0.975, "percentile": 99.9},
    "CVE-2019-0708":  {"epss_score": 0.974, "percentile": 99.8},
    "CVE-2020-0601":  {"epss_score": 0.350, "percentile": 88.0},
    "CVE-2021-26855": {"epss_score": 0.975, "percentile": 99.9},
    "CVE-2023-27997": {"epss_score": 0.800, "percentile": 97.0},
    "CVE-2022-42475": {"epss_score": 0.900, "percentile": 98.5},
}


class ThreatFeedCache:
    """Cache for CISA KEV and EPSS threat-intelligence feeds.

    Supports three modes:
    - ``offline``: static built-in snapshots only (no network)
    - ``live``: always fetch from upstream APIs
    - ``fallback`` (default): try live, fall back to static on failure
    """

    _KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
    _EPSS_URL = "https://api.first.org/data/v1/epss"
    _CVEFEED_URL = "https://cvefeed.io/vuln/detail"

    def __init__(self, mode: str = "fallback", cache_ttl: int = 86400) -> None:
        self._mode = mode  # live, offline, fallback
        self._cache_ttl = cache_ttl
        self._kev_index: dict[str, dict[str, str]] = dict(_KEV_INDEX)
        self._epss_data: dict[str, dict[str, Any]] = dict(_EPSS_DATA)
        self._cve_cache: dict[str, dict] = {}
        self._kev_last_refresh: float = 0
        self._epss_last_refresh: float = 0
        logger.info(
            "ThreatFeedCache initialised",
            mode=mode,
            kev_entries=len(self._kev_index),
            epss_entries=len(self._epss_data),
        )

    # -- Live fetch methods -------------------------------------------------

    async def ensure_kev_fresh(self) -> None:
        """Refresh KEV catalog from CISA if stale."""
        if self._mode == "offline":
            return
        if time.time() - self._kev_last_refresh < self._cache_ttl:
            return
        try:
            async with httpx.AsyncClient(timeout=30) as client:
                resp = await client.get(self._KEV_URL)
                resp.raise_for_status()
                data = resp.json()
                vulns = data.get("vulnerabilities", [])
                for v in vulns:
                    cve_id = v.get("cveID", "").upper()
                    if cve_id:
                        self._kev_index[cve_id] = {
                            "cve_id": cve_id,
                            "vendor": v.get("vendorProject", ""),
                            "product": v.get("product", ""),
                            "description": v.get("shortDescription", ""),
                            "date_added": v.get("dateAdded", ""),
                            "required_action": v.get("requiredAction", ""),
                        }
                self._kev_last_refresh = time.time()
                logger.info("KEV catalog refreshed", total=len(self._kev_index))
        except Exception as e:
            if self._mode == "live":
                logger.error("KEV fetch failed (live mode)", error=str(e))
            else:
                logger.warning("KEV fetch failed, using static fallback", error=str(e))

    async def ensure_epss_fresh(self, cve_ids: list[str]) -> None:
        """Batch-refresh EPSS scores for specific CVE IDs."""
        if self._mode == "offline" or not cve_ids:
            return
        # Only fetch CVEs we don't have fresh data for
        stale = [c for c in cve_ids if c.strip().upper() not in self._epss_data
                 or time.time() - self._epss_last_refresh > self._cache_ttl]
        if not stale:
            return
        try:
            # EPSS API accepts up to 100 CVEs per request
            for i in range(0, len(stale), 100):
                batch = stale[i:i + 100]
                csv_list = ",".join(batch)
                async with httpx.AsyncClient(timeout=30) as client:
                    resp = await client.get(f"{self._EPSS_URL}?cve={csv_list}")
                    resp.raise_for_status()
                    data = resp.json()
                    for item in data.get("data", []):
                        cve_id = item.get("cve", "").upper()
                        if cve_id:
                            self._epss_data[cve_id] = {
                                "epss_score": float(item.get("epss", 0)),
                                "percentile": float(item.get("percentile", 0)) * 100,
                            }
            self._epss_last_refresh = time.time()
            logger.info("EPSS scores refreshed", count=len(stale))
        except Exception as e:
            if self._mode == "live":
                logger.error("EPSS fetch failed (live mode)", error=str(e))
            else:
                logger.warning("EPSS fetch failed, using static fallback", error=str(e))

    async def lookup_cve(self, cve_id: str) -> dict | None:
        """Lookup a CVE via cvefeed.io with caching."""
        import re as _re
        import json as _json

        cve_id = cve_id.strip().upper()
        if cve_id in self._cve_cache:
            return self._cve_cache[cve_id]
        if self._mode == "offline":
            return None
        try:
            async with httpx.AsyncClient(timeout=30, follow_redirects=True) as client:
                resp = await client.get(f"{self._CVEFEED_URL}/{cve_id}")
                resp.raise_for_status()
                html = resp.text

                # Extract JSON-LD structured data
                desc = ""
                published = None
                ld_matches = _re.findall(
                    r'<script[^>]*type="application/ld\+json"[^>]*>(.*?)</script>',
                    html, _re.DOTALL,
                )
                for m in ld_matches:
                    try:
                        ld = _json.loads(m)
                        if ld.get("@type") == "TechArticle":
                            desc = ld.get("articleBody", "")
                            published = ld.get("datePublished")
                            break
                    except Exception:
                        pass

                # Extract CVSS v3.1 score
                cvss_score = None
                cvss_severity = None
                score_match = _re.search(r'score-\d+">\s*(\d+\.?\d*)', html)
                if score_match:
                    cvss_score = float(score_match.group(1))
                    if cvss_score >= 9:
                        cvss_severity = "CRITICAL"
                    elif cvss_score >= 7:
                        cvss_severity = "HIGH"
                    elif cvss_score >= 4:
                        cvss_severity = "MEDIUM"
                    else:
                        cvss_severity = "LOW"

                # Extract CVSS vector
                vector_match = _re.search(r'(CVSS:3\.1/[A-Z:/]+)', html)
                cvss_vector = vector_match.group(1) if vector_match else None

                # Extract CWEs
                cwes = list(set(_re.findall(r'CWE-(\d+)', html)))

                result = {
                    "cve_id": cve_id,
                    "description": desc,
                    "cvss_v31_score": cvss_score,
                    "cvss_v31_severity": cvss_severity,
                    "cvss_v31_vector": cvss_vector,
                    "cwes": cwes,
                    "published": published,
                    "source": "cvefeed.io",
                    "url": f"https://cvefeed.io/vuln/detail/{cve_id}",
                }
                self._cve_cache[cve_id] = result
                return result
        except Exception as e:
            logger.warning("CVE lookup failed", cve_id=cve_id, error=str(e))
            return None

    # -- public API ---------------------------------------------------------

    def get_kev_status(self, cve_id: str) -> dict | None:
        """Return KEV entry for *cve_id*, or ``None`` if not present."""
        cve_id = cve_id.strip().upper()
        entry = self._kev_index.get(cve_id)
        if entry is None:
            return None
        return {
            "cve_id": entry["cve_id"],
            "vendor": entry.get("vendor", ""),
            "product": entry.get("product", ""),
            "description": entry.get("description", ""),
            "date_added": entry.get("date_added", ""),
            "required_action": entry.get("required_action", ""),
            "in_kev": True,
        }

    def get_epss_score(self, cve_id: str) -> dict | None:
        """Return EPSS data for *cve_id*, or ``None`` if not present."""
        cve_id = cve_id.strip().upper()
        entry = self._epss_data.get(cve_id)
        if entry is None:
            return None
        return {
            "cve_id": cve_id,
            "epss_score": entry["epss_score"],
            "percentile": entry["percentile"],
        }

    def get_feed_stats(self) -> dict:
        """Return current feed status and counts."""
        return {
            "mode": self._mode,
            "kev_count": len(self._kev_index),
            "epss_count": len(self._epss_data),
            "cve_cached": len(self._cve_cache),
            "kev_last_refresh": self._kev_last_refresh,
            "epss_last_refresh": self._epss_last_refresh,
        }

    # -- bulk helpers -------------------------------------------------------

    def bulk_kev_check(self, cve_ids: list[str]) -> dict[str, dict | None]:
        """Check multiple CVEs against KEV in one call."""
        return {cve_id: self.get_kev_status(cve_id) for cve_id in cve_ids}

    def bulk_epss_check(self, cve_ids: list[str]) -> dict[str, dict | None]:
        """Retrieve EPSS data for multiple CVEs in one call."""
        return {cve_id: self.get_epss_score(cve_id) for cve_id in cve_ids}

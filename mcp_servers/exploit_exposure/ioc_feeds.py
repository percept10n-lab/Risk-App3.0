"""IoC feed clients for abuse.ch (URLhaus, ThreatFox) and crt.sh."""

from __future__ import annotations

import httpx
import structlog

logger = structlog.get_logger()


class IoCFeedClient:
    """Query free IoC feeds: URLhaus, ThreatFox, and crt.sh."""

    async def query_urlhaus(self, host: str) -> dict | None:
        """Query URLhaus for malicious URLs associated with a host."""
        try:
            async with httpx.AsyncClient(timeout=15) as client:
                resp = await client.post(
                    "https://urlhaus-api.abuse.ch/v1/host/",
                    data={"host": host},
                )
                resp.raise_for_status()
                data = resp.json()
                if data.get("query_status") == "no_results":
                    return None
                return {
                    "host": host,
                    "url_count": data.get("url_count", 0),
                    "urls_online": data.get("urls_online", 0),
                    "blacklists": data.get("blacklists", {}),
                    "urls": [
                        {
                            "url": u.get("url"),
                            "status": u.get("url_status"),
                            "threat": u.get("threat"),
                            "date_added": u.get("date_added"),
                        }
                        for u in (data.get("urls") or [])[:10]
                    ],
                }
        except Exception as e:
            logger.warning("URLhaus query failed", host=host, error=str(e))
            return None

    async def query_threatfox(self, search_term: str) -> dict | None:
        """Query ThreatFox for IoC matches."""
        try:
            async with httpx.AsyncClient(timeout=15) as client:
                resp = await client.post(
                    "https://threatfox-api.abuse.ch/api/v1/",
                    json={"query": "search_ioc", "search_term": search_term},
                )
                resp.raise_for_status()
                data = resp.json()
                if data.get("query_status") == "no_result":
                    return None
                results = data.get("data", [])
                return {
                    "search_term": search_term,
                    "result_count": len(results),
                    "indicators": [
                        {
                            "ioc": r.get("ioc"),
                            "ioc_type": r.get("ioc_type"),
                            "threat_type": r.get("threat_type"),
                            "malware": r.get("malware"),
                            "confidence_level": r.get("confidence_level"),
                            "first_seen": r.get("first_seen_utc"),
                        }
                        for r in results[:20]
                    ],
                }
        except Exception as e:
            logger.warning("ThreatFox query failed", search_term=search_term, error=str(e))
            return None

    async def query_crtsh(self, domain: str) -> list[dict]:
        """Query crt.sh for certificate transparency logs."""
        try:
            async with httpx.AsyncClient(timeout=20) as client:
                resp = await client.get(
                    f"https://crt.sh/?q={domain}&output=json",
                )
                resp.raise_for_status()
                data = resp.json()
                return [
                    {
                        "id": entry.get("id"),
                        "issuer_name": entry.get("issuer_name"),
                        "common_name": entry.get("common_name"),
                        "name_value": entry.get("name_value"),
                        "not_before": entry.get("not_before"),
                        "not_after": entry.get("not_after"),
                        "serial_number": entry.get("serial_number"),
                    }
                    for entry in data[:50]
                ]
        except Exception as e:
            logger.warning("crt.sh query failed", domain=domain, error=str(e))
            return []

import asyncio
import uuid
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import OperationalError
from sqlalchemy import select

from app.database import get_db, async_session
from app.models.finding import Finding
from app.models.audit_event import AuditEvent
from app.services.pentest_service import PentestService, AVAILABLE_ACTIONS
from app.api.ws import manager

router = APIRouter()


class PentestExecuteRequest(BaseModel):
    action_id: str
    target: str
    run_id: str | None = None
    params: dict | None = None


@router.get("/actions")
async def list_actions():
    """List all available pentest actions."""
    actions = [
        {"id": k, "name": v["name"], "description": v["description"], "risk": v["risk"]}
        for k, v in AVAILABLE_ACTIONS.items()
    ]
    return {"actions": actions}


@router.post("/execute")
async def execute_action(request: PentestExecuteRequest):
    """Execute a pentest action against a target."""
    run_id = request.run_id or f"pentest-{uuid.uuid4().hex[:12]}"

    async def broadcast(msg: str):
        await manager.broadcast(run_id, {
            "type": "pentest_progress",
            "message": msg,
            "timestamp": datetime.utcnow().isoformat() + "Z",
        })

    for attempt in range(3):
        try:
            async with async_session() as db:
                service = PentestService(db)
                result = await service.execute_action(
                    action_id=request.action_id,
                    target=request.target,
                    run_id=run_id,
                    params=request.params,
                    broadcast=broadcast,
                )
                await db.commit()
                result["run_id"] = run_id
                return result
        except OperationalError:
            if attempt < 2:
                await asyncio.sleep(2 * (attempt + 1))
                continue
            raise HTTPException(status_code=503, detail="Database busy, please retry")


@router.post("/verify-scope")
async def verify_scope(target: str):
    """Check if a target is within allowed scope."""
    service = PentestService.__new__(PentestService)
    in_scope = service.validate_scope(target)
    return {"target": target, "in_scope": in_scope}


@router.get("/results")
async def list_results(
    run_id: str | None = None,
    target: str | None = None,
    db: AsyncSession = Depends(get_db),
):
    """List pentest findings."""
    query = select(Finding).where(Finding.source_tool.like("pentest_%"))
    if target:
        from app.models.asset import Asset
        asset_result = await db.execute(select(Asset).where(Asset.ip_address == target))
        asset = asset_result.scalar_one_or_none()
        if asset:
            query = query.where(Finding.asset_id == asset.id)
    if run_id:
        query = query.where(Finding.run_id == run_id)

    result = await db.execute(query.order_by(Finding.created_at.desc()).limit(1000))
    findings = result.scalars().all()
    return {
        "results": [
            {
                "id": f.id,
                "title": f.title,
                "severity": f.severity,
                "category": f.category,
                "source_tool": f.source_tool,
                "evidence": f.raw_output_snippet,
                "remediation": f.remediation,
            }
            for f in findings
        ],
        "total": len(findings),
    }


@router.get("/history")
async def get_history(
    limit: int = Query(50, ge=1, le=200),
    db: AsyncSession = Depends(get_db),
):
    """Get history of pentest executions from audit trail."""
    result = await db.execute(
        select(AuditEvent)
        .where(AuditEvent.entity_type == "pentest")
        .order_by(AuditEvent.timestamp.desc())
        .limit(limit)
    )
    events = result.scalars().all()
    return {
        "history": [
            {
                "id": e.id,
                "action": e.action,
                "timestamp": e.timestamp.isoformat() if e.timestamp else None,
                "actor": e.actor,
                "details": e.new_value,
                "run_id": e.run_id,
            }
            for e in events
        ],
        "total": len(events),
    }

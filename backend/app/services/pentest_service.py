import json
import ipaddress
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.asset import Asset
from app.models.finding import Finding
from app.evidence.artifact_store import ArtifactStore
from app.evidence.audit_trail import AuditTrail
from app.services.finding_service import FindingService
import structlog

logger = structlog.get_logger()

PRIVATE_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
]

AVAILABLE_ACTIONS = {
    "port_verify": {
        "name": "Port Verification",
        "description": "Scan target for open ports and verify service availability",
        "risk": "low",
    },
    "http_headers": {
        "name": "HTTP Security Headers",
        "description": "Check HTTP response headers for security best practices (HSTS, CSP, X-Frame-Options)",
        "risk": "low",
    },
    "tls_check": {
        "name": "TLS Configuration Check",
        "description": "Verify TLS certificate validity, protocol versions, and cipher suite strength",
        "risk": "low",
    },
    "ssh_hardening": {
        "name": "SSH Hardening Check",
        "description": "Audit SSH server configuration for weak algorithms, key exchange, and authentication settings",
        "risk": "low",
    },
    "upnp_check": {
        "name": "UPnP Discovery Check",
        "description": "Detect UPnP services that may expose the network to external attacks",
        "risk": "low",
    },
    "admin_exposure": {
        "name": "Admin Interface Exposure",
        "description": "Probe for exposed admin interfaces (web panels, management ports) accessible on the network",
        "risk": "medium",
    },
    "waf_detect": {
        "name": "WAF Detection",
        "description": "Detect web application firewalls using probe requests, signature matching, and behavioral analysis",
        "risk": "low",
    },
    "web_vuln_probe": {
        "name": "Web Vulnerability Probe",
        "description": "Probe for CORS, clickjacking, sensitive paths, XSS reflection, SQLi errors, open redirect, and debug disclosure",
        "risk": "medium",
    },
    "service_fingerprint": {
        "name": "Service Fingerprint",
        "description": "Detect CMS, frameworks, web servers, and programming languages from HTTP responses",
        "risk": "low",
    },
    "exploit_chain": {
        "name": "Exploit Chain Analyzer",
        "description": "Analyze existing pentest findings to identify multi-step attack chains and escalation paths",
        "risk": "low",
    },
}


class PentestService:
    def __init__(self, db: AsyncSession):
        self.db = db
        self.artifact_store = ArtifactStore(db)
        self.audit_trail = AuditTrail(db)
        self.finding_service = FindingService(db)

    def validate_scope(self, target: str) -> bool:
        """Validate target is in RFC 1918 private range."""
        try:
            ip = ipaddress.ip_address(target)
            return any(ip in net for net in PRIVATE_NETWORKS)
        except ValueError:
            return False

    async def execute_action(
        self, action_id: str, target: str, run_id: str | None = None, params: dict | None = None
    ) -> dict:
        """Execute a pentest action against a target."""
        if action_id not in AVAILABLE_ACTIONS:
            return {"status": "error", "error": f"Unknown action: {action_id}"}

        if not self.validate_scope(target):
            return {"status": "error", "error": f"Target {target} is outside allowed scope (RFC 1918 only)"}

        logger.info("Executing pentest action", action=action_id, target=target)

        # Run network action FIRST (no DB needed), then batch DB writes after
        raw_findings = []
        try:
            raw_findings = await self._run_action(action_id, target, params or {})
        except Exception as e:
            logger.error("Pentest action failed", action=action_id, error=str(e))
            return {"status": "error", "error": str(e)}

        # All DB writes happen here, after network I/O is complete
        await self.audit_trail.log(
            event_type="action", entity_type="pentest",
            entity_id=action_id, actor="user",
            action=f"pentest_{action_id}",
            run_id=run_id,
            new_value={"target": target, "params": params or {}},
        )

        # Find or create asset
        result = await self.db.execute(
            select(Asset).where(Asset.ip_address == target)
        )
        asset = result.scalar_one_or_none()
        asset_id = asset.id if asset else None

        # Store findings
        created = 0
        findings_list = []
        for raw in raw_findings:
            if raw.get("severity") == "info":
                findings_list.append(raw)
                continue

            if asset_id:
                finding_data = {
                    "asset_id": asset_id,
                    "run_id": run_id,
                    "title": raw["title"],
                    "description": raw.get("description", ""),
                    "severity": raw.get("severity", "info"),
                    "category": raw.get("category", "exposure"),
                    "source_tool": f"pentest_{action_id}",
                    "source_check": action_id,
                    "cwe_id": raw.get("cwe_id"),
                    "evidence_artifact_ids": [],
                    "raw_output_snippet": raw.get("evidence", ""),
                    "remediation": raw.get("remediation"),
                }
                finding, is_new = await self.finding_service.create_deduplicated(finding_data)
                if is_new:
                    created += 1
            findings_list.append(raw)

        # Store artifact
        await self.artifact_store.store(
            content=json.dumps(findings_list, indent=2, default=str),
            artifact_type="raw_output",
            tool_name=f"pentest_{action_id}",
            target=target,
            run_id=run_id,
            command=f"pentest {action_id} target={target}",
            parameters={"action": action_id, "target": target, **(params or {})},
        )

        return {
            "status": "completed",
            "action": action_id,
            "target": target,
            "findings": findings_list,
            "findings_created": created,
            "total_findings": len(findings_list),
        }

    async def _run_action(self, action_id: str, target: str, params: dict) -> list[dict]:
        """Execute the actual pentest action."""
        if action_id == "port_verify":
            from mcp_servers.pentest_automation.actions.port_verify import PortVerifyAction
            action = PortVerifyAction()
            return await action.execute(target, params.get("ports"))

        elif action_id == "http_headers":
            from mcp_servers.pentest_automation.actions.http_headers import HTTPHeadersAction
            action = HTTPHeadersAction()
            return await action.execute(
                target, params.get("port", 80), params.get("use_tls", False)
            )

        elif action_id == "tls_check":
            from mcp_servers.pentest_automation.actions.tls_check import TLSCheckAction
            action = TLSCheckAction()
            return await action.execute(target, params.get("port", 443))

        elif action_id == "ssh_hardening":
            from mcp_servers.pentest_automation.actions.ssh_hardening import SSHHardeningAction
            action = SSHHardeningAction()
            return await action.execute(target, params.get("port", 22))

        elif action_id == "upnp_check":
            from mcp_servers.pentest_automation.actions.upnp_check import UPnPCheckAction
            action = UPnPCheckAction()
            return await action.execute(target)

        elif action_id == "admin_exposure":
            from mcp_servers.pentest_automation.actions.admin_exposure import AdminExposureAction
            action = AdminExposureAction()
            return await action.execute(target, params.get("ports"))

        elif action_id == "waf_detect":
            from mcp_servers.pentest_automation.actions.waf_detect import WAFDetectAction
            action = WAFDetectAction()
            return await action.execute(target, params.get("port", 80), params.get("use_tls", False))

        elif action_id == "web_vuln_probe":
            from mcp_servers.pentest_automation.actions.web_vuln_probe import WebVulnProbeAction
            action = WebVulnProbeAction()
            return await action.execute(target, params.get("port", 80), params.get("use_tls", False))

        elif action_id == "service_fingerprint":
            from mcp_servers.pentest_automation.actions.service_fingerprint import ServiceFingerprintAction
            action = ServiceFingerprintAction()
            return await action.execute(target, params.get("port", 80), params.get("use_tls", False))

        elif action_id == "exploit_chain":
            from mcp_servers.pentest_automation.actions.exploit_chain import ExploitChainAction
            # Query existing findings for this target from DB
            result = await self.db.execute(
                select(Asset).where(Asset.ip_address == target)
            )
            asset = result.scalar_one_or_none()
            existing_findings = []
            if asset:
                findings_result = await self.db.execute(
                    select(Finding).where(
                        Finding.asset_id == asset.id,
                        Finding.source_tool.like("pentest_%"),
                    )
                )
                for f in findings_result.scalars().all():
                    existing_findings.append({
                        "title": f.title,
                        "description": f.description or "",
                        "severity": f.severity or "info",
                        "category": f.category or "",
                        "source_tool": f.source_tool or "",
                        "cwe_id": getattr(f, "cwe_id", None),
                    })
            action = ExploitChainAction()
            return await action.execute(target, findings=existing_findings)

        return []
